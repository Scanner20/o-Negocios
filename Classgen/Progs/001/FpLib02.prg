**************
PROCEDURE MONO
**************
SET COLOR OF SCHEME  1 TO W/N,N+/W,N/W,W+/N,N/W,N+/W,U+/N,N+/N,W/N,N/W,-
SET COLOR OF SCHEME  2 TO W/N,W+/N,W+/N,W+/N,W/N,N+/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  3 TO W/N,N/W,N/W,W+/N,W+/N,W+/N,N+/W,N+/N,W+/N,N+/W,-
SET COLOR OF SCHEME  4 TO W/N,W+/N,W+/N,W+/N,W/N,N+/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  5 TO W/N,W+/N,W+/N,W+/N,W+/N,N+/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  6 TO W/N,W+/N,W+/N,W+/N,W+/N,N+/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  7 TO N+/W,N/W,N/W,N+/W,N/W,W+/N,U+/N,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME  8 TO W/N,U+/N,N/W,N+/W,N/W,N/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  9 TO W/N,W+/N,W+/N,N+/W,N/W,N/W,N/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 10 TO W/N,N+/W,N/W,N+/W,N/W,U+/N,N/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 11 TO W+/N,U+/N,N/W,N+/W,N/W,N/W,W/N,N+/N,N/W,W/N,-
SET COLOR OF SCHEME 12 TO W/N,N+/W,N/W,W+/N,W/N,N+/W,U+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 13 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 14 TO N+/W,N/W,N/W,N+/W,N/W,W+/N,U+/N,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 15 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 16 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 17 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 18 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 19 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 20 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 21 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 22 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 23 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 24 TO W/N,N+/W,W+/N,W+/N,W/N,U+/N,W+/N,N+/N,W+/N,W/N,-
RETURN

******************
PROCEDURE MONO_VGA
******************
SET COLOR OF SCHEME  1 TO W/N,N+/W,N/W,W+/N,N/W,N+/W,G+,N+/N,W/N,N/W,-
SET COLOR OF SCHEME  2 TO B+,W/N,W+/N,W+/N,W/N,N+/W,G+,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  3 TO W/N,N/W,N/W,W+/N,W+/N,W+/N,N+/W,N+/N,W+/N,N+/W,-
SET COLOR OF SCHEME  4 TO W/N,W+/N,W+/N,W+/N,W/N,N+/W,B+/W,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  5 TO W/N,W+/N,W+/N,W+/N,W+/N,N+/W,B+/W,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  6 TO W/N,W+/N,W+/N,W+/N,W+/N,N+/W,B+/W,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  7 TO N+/W,N/W,N/W,N+/W,N/W,W+/N,B+/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME  8 TO W/N,B+/W,N/W,N+/W,N/W,N/W,B+/W,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME  9 TO W/N,W+/N,W+/N,N+/W,N/W,N/W,N/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 10 TO W/N,N+/W,N/W,N+/W,N/W,B+/W,N/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 11 TO W+/N,G+/W,N/W,N+/W,N/W,N/W,W/N,N+/N,N/W,W/N,-
SET COLOR OF SCHEME 12 TO W/N,N+/W,N/W,W+/N,W/N,N+/W,B+/W,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 13 TO W/N,N+/W,W+/N,W+/N,W/N,B+/W,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 14 TO N+/W,N/W,N/W,N+/W,N/W,W+/N,B+/W,N+/N,N+/W,N/W,-
SET COLOR OF SCHEME 15 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 16 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 17 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 18 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 19 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 20 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 21 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 22 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 23 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-
SET COLOR OF SCHEME 24 TO W/N,N+/W,W+/N,W+/N,W/N,G+,W+/N,N+/N,W+/N,W/N,-


RETURN

***************
PROCEDURE COLOR
***************
SET COLOR OF SCHEME  1 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME  2 TO BG/W,N/W,N/W,B/W,W/N,N/BG,W+/W,N+/N,B/W,W/N,+
SET COLOR OF SCHEME  3 TO BG/W,N/W,BG/N,BG/N,BG/N,N/BG,W+/W,N+/N,BG/N,BG/N,+
SET COLOR OF SCHEME  4 TO BG/W,N/W,N/W,B/W,W/N,N/BG,W+/W,N+/N,B/W,W/N,+
SET COLOR OF SCHEME  5 TO W+/RB,W+/BG,W+/RB,W+/RB,W/RB,W+/B,GR+/RB,N+/N,W+/RB,W/RB,+
SET COLOR OF SCHEME  6 TO W/BG,W+/BG,W+/RB,W+/RB,W/RB,W+/B,BG+/BG,N+/N,W+/RB,W/RB,+
SET COLOR OF SCHEME  7 TO B/W,W+/W,GR+/R,W+/R,W/R,W+/N,GR+/R,N+/N,W+/R,W/R,+
SET COLOR OF SCHEME  8 TO W+/BG,W+/W,GR+/W,GR+/W,N+/W,W+/GR,BG+/BG,N+/N,B/BG,W/BG,+
SET COLOR OF SCHEME  9 TO W/BG,W+/BG,B/BG,GR+/W,N+/W,W+/GR,W+/B,N+/N,GR+/W,N+/W,+
SET COLOR OF SCHEME 10 TO W+/BG,GR+/B,GR+/W,GR+/W,N+/W,GR+/GR,W+/B,N+/N,GR+/W,N+/W,+
SET COLOR OF SCHEME 11 TO W+/BG,W+/W,GR+/W,GR+/W,N+/W,W+/GR,W/B,N+/N,W+/B,W/BG,+
SET COLOR OF SCHEME 12 TO GR+/R,W+/W,GR+/R,W+/R,W/R,W+/N,GR+/R,N+/N,W+/R,W/R,+
*SET COLOR OF SCHEME 13 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
*SET COLOR OF SCHEME 14 TO W+/G,W+/RB,W+/RB,W+/RB,W/RB,W+/B,BG+/BG,N+/N,W+/RB,W/RB,+
*SET COLOR OF SCHEME 15 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
*SET COLOR OF SCHEME 16 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 17 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 18 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 19 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 20 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 21 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 22 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 23 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
SET COLOR OF SCHEME 24 TO W+/B,W+/BG,GR+/B,GR+/B,R+/B,W+/GR,GR+/RB,N+/N,GR+/B,R+/B,+
RETURN

**********************
PROCEDURE COPIA_ILEGAL
**********************
?? chr(7)
?? chr(7)
?? chr(7)
?? chr(7)
?? chr(7)
@  4,26 SAY "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" COLOR SCHEME 7
@  5,26 SAY "³    ***** Copia Ilegal del sistema  ****     ³" COLOR SCHEME 7
@  6,26 SAY "³                                             ³" COLOR SCHEME 7
@  7,26 SAY "³                                             ³" COLOR SCHEME 7
@  8,26 SAY "³    Reinstale el disco llave del sistema     ³" COLOR SCHEME 7
@  9,26 SAY "³                                             ³" COLOR SCHEME 7
@ 10,26 SAY "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ" COLOR SCHEME 7
@ 11,26 SAY "                                               "

GsMsgErr = "                                      "
do lib_merr with 99
RETURN
*****************
PROCEDURE INSTALL
*****************
CLEAR
@ 14,21 SAY "INSTALANDO UN NUEVO TERMINAL AL SISTEMA" COLOR -
USE terminal.fxp ALIAS TERM
IF RECCOUNT() < 1
   GsMsgErr = "No existe Terminal en L¡nea"
   DO LIB_MERR WITH 99
   CLOSE DATA
   RETURN
ENDIF
GOTO 1
*** VERIFICAMOS SI ESTA BLOQUEADO ***
IF RLOCK()
   GsMsgErr = "No existe Terminal en L¡nea"
   DO LIB_MERR WITH 99
   CLOSE DATA
   RETURN
ENDIF
xTerminal = DESCRIPT(Terminal,recno())
IF EMPTY(xTerminal)
   GsMsgErr = "No existe Terminal en L¡nea"
   DO LIB_MERR WITH 99
   CLOSE DATA
   RETURN
ENDIF
IF ! FILE("INFOLOCK.COM")
   GsMsgErr = "No existe Terminal en L¡nea"
   DO LIB_MERR WITH 99
   CLOSE DATA
   RETURN
ENDIF
@ 16,0 SAY PADC("TERMINAL "+xTerminal,80) color -
load infolock.com
DO WHILE INKEY() # 0
ENDDO
CALL infolock
release module infolock
A=CHR(INKEY())
DO CASE
   CASE A="1"
   CASE A="2"
     CLOSE DATA
     RETURN
   CASE A="3"
     DO COPIA_ILEGAL
     QUIT
ENDCASE
APPEND BLANK
IF RLOCK()
   yTerminal = SYS(2007,xTerminal)
   xTerminal = PADR(xTerminal+ENCRIPTA(yTerminal,VAL(yTerminal)),LEN(Terminal))
   REPLACE  TERMINAL WITH ENCRIPTA(xTerminal,RECNO())
ENDIF
CLOSE DATA
RETURN
**************************************************************************
function abrowse
****************
PRIVATE    FINAL,CURSOR,dLBrows,CT,CB,Y1,X1,Sigue,j,Si,No,i,Ok,;
           LonEst,LinEst, LinPan, ActPan, LeeReg , FLGins, LinIni
PRIVATE    LinAct,LinFin,EleIni,EleAct
* Constantes y variables -------------------------------------------------
FINAL     = CHR(escape_)+CHR(CtrlW)
CURSOR    = FINAL + CHR(Abajo)+CHR(Arriba)+CHR(PgUp)+CHR(PgDn)+;
            +CHR(Enter)+CHR(Del)+CHR(Ins) +CHR(Home)+CHR(End)
i         = 0                          && Tecla le¡da con INKEY().
* ---------------------------------------
Si        = .T.
No        = .F.
Ok        = No
CT        = No                         && Indica si hay registros arriba.
CB        = No                         && Idem, abajo.
Sigue     = Si                         && Control del lazo principal.
FLGins    = No                         && Insertando linea
*
* --------------------------------------- Elementos de manejo de pantalla.
*
Y1        = 0                          && Fila coordenada inferior derecho.
X1        = 0                          && Columna inferior derecha.
LinIni    = 0                          && L¡nea inicial en pantalla.
LinAct    = 0                          && L¡nea activa en pantalla.
LinFin    = 0                          && L¡nea final en pantalla.
EleIni    = 1                          && Elemento inicial en pantalla.
EleAct    = 1                          && Elemento activo en pantalla.
ActPan    = Si                         && ¨Actualizar pantalla?.
LeeReg    = Si                         && ¨Leer registro activo?.
LonEst    = 0                          && Longitud de la barra vertical de
                                       && estado (derecha de la ventana).
LinEst    = 0                          && Marca la posici¢n relativa dentro
                                       && del archivo.
LinPan    = 0                          && N£mero de l¡neas que tendr  la
                                       && pantalla de trabajo.
* ------------------------------------------------------------------------
IF .NOT. TYPE("PrgFin")="C"
   PRIVATE PrgFin
   PrgFin = []
ENDIF

* Dibuja el Marco  -------------------------------------------------------
@ Yo+1,Xo+1 CLEAR TO Yo+Largo-2,Xo+Ancho-2
DO CASE
   CASE TBorde = 0
   CASE TBorde = 2
      @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 DOUBLE
   CASE TBorde = 3
      @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 PANEL
   OTHER
      @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1
ENDCASE
IF ! Titulo == ""
   Col = INT((Ancho-2 - LEN(Titulo))/2)
   Col = iif(Col>0,Col,0)
   @ Yo,Xo + Col SAY LEFT(Titulo,Ancho-2)   COLOR SCHEME 7
ENDIF
* ------------------------------------------------------------------------
* Dibuja encabezados si existen y mensajes si se indica ------------------
Y1        = Yo + Largo - 1             && Fila coordenada inferior derecho.
X1        = Xo + Ancho - 1             && Columna inferior derecha.
Lin       = 0
IF "" <> En1
   @ Yo+1,Xo+1 SAY En1 SIZE 1,Ancho-2 COLOR SCHEME 7
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF "" <> En2
   @ Yo+1,Xo+1 SAY En2 SIZE 1,Ancho-2 COLOR SCHEME 7
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF "" <> En3
   @ Yo+1,Xo+1 SAY En3 SIZE 1,Ancho-2 COLOR SCHEME 7
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF Lin > 0
   *IF VSombra .AND. Xo > 0
   *   *@ Yo+1,Xo-1 FILL Yo+Largo,Xo+Ancho-2 COLOR N/W
   *ENDIF
   DO CASE
      CASE TBorde = 0
      CASE TBorde = 2
         @ Yo+1,Xo         SAY "Ç"
         @ Yo+1,Xo+1 TO Yo+1,Xo+Ancho-2
         @ Yo+1,Xo+Ancho-1 SAY "¶"
      CASE TBorde = 3
         @ Yo+1,Xo TO Yo+1,Xo+Ancho-1 PANEL
      OTHER
         @ Yo+1,Xo         SAY "Ã"
         @ Yo+1,Xo+1 TO Yo+1,Xo+Ancho-2
         @ Yo+1,Xo+Ancho-1 SAY "´"
   ENDCASE
   Yo = Yo + 1
ENDIF
LinIni    = Yo + 1                     && L¡nea inicial en pantalla.
LinFin    = Y1 - 1                     && L¡nea final en pantalla.
LinAct    = LinIni                     && L¡nea activa en pantalla.
LinEst    = LinIni + 1                 && Marca la posici¢n relativa.
LinPan    = LinFin - LinIni + 1        && N£mero de l¡neas por pantalla.
LonEst    = IIF(LinPan<2, 0, LinPan-2) && Longitud de la barra vertical.
* ------------------------------------------------------------------------
* L¢gica principal -------------------------------------------------------
* - Lazo principal del sistema, se ejecuta hasta que el usuario salga con
*   Escape o Ctrl-W.
IF MaxEle > 0                          && Insertamos una l¡nea si no existe
   LeeReg = No
ENDIF
RepPan = Si
DO WHILE Sigue
   IF MaxEle = 0                          && Insertamos una l¡nea si no existe
      DO &InsLin WITH 0, Ok               && ninguna.
      IF ! Ok
         EXIT
      ENDIF
      MaxEle = 1
      LeeReg = Si                         && Si no hay ning£n registro, empezar
      FLGins = Si                         && Insertando l¡nea
   ENDIF
   IF ActPan
      * - Actualiza el contenido de la pantalla si ActPan es verdadero.
      j = IIF(RepPan,LinAct-LinIni+1,1)
      DO WHILE j <= LinPan .AND. (EleIni+j-1) <= MaxEle
         DO &EscLin WITH (EleIni+j-1), (LinIni+j-1)
         j = j + 1
      ENDDO
      RepPan = No
      IF j <= LinPan
         @ LinIni+j-1, Xo+1 CLEAR TO LinFin, X1-1
      ENDIF
      CT = IIF( EleIni > 1, Si, No)    && ¨Hay elementos hacia arriba?
      CB = IIF( (MaxEle-EleIni) >= LinPan, Si, No)    && ¨Hacia abajo?
      @ Yo+1, X1 SAY IIF(! CT,"þ","")        COLOR SCHEME 7
      @ Y1-1, X1 SAY IIF(! CB,"þ","")        COLOR SCHEME 7
      ActPan = No
   ENDIF
   @ Y1, Xo+1 SAY STR(EleAct,3)+"/"+STR(MaxEle,3) COLOR SCHEME 7
   IF LeeReg
      * Escribe la l¡nea activa.
      DO &EscLin WITH EleAct, LinAct
      * Edita la l¡nea activa.
      DO WHILE Si
         DO &EdiLin WITH EleAct, LinAct
         IF INLIST(UltTecla,escape_,CtrlW,Abajo,Arriba,Enter,F10)
            EXIT
         ENDIF
      ENDDO
      LeeReg = No                      && Se asume que no leer  el registro
      i = UltTecla
      IF FLGins .AND. INLIST(UltTecla,escape_,Arriba)
         IF MaxEle = 1
            LeeReg = Si
            IF UltTecla = escape_
               EXIT
            ENDIF
            LOOP
         ENDIF
         DO &BrrLin WITH EleAct-1, Ok
         IF Ok
            IF MaxEle = 1
               IF UltTecla = escape_
                  Sigue = No
               ENDIF
               LOOP
            ENDIF
            MaxEle = MaxEle - 1        && Disminuye el n£mero de elementos.
            IF EleAct > MaxEle
               EleAct = EleAct - 1
               LinAct = LinAct - 1
            ENDIF
            IF EleAct < EleIni
               EleIni = EleIni - LinPan      && Pantalla anterior.
               EleAct = EleIni + LinPan - 1
               LinAct = LinFin
            ELSE
               RepPan = Si
            ENDIF
            ActPan = Si
         ELSE
            ?? CHR(7)
         ENDIF
         FLGins = No
         LOOP
      ENDIF
      FLGins = No
      * Escribe la l¡nea activa.
      i = UltTecla
      DO &EscLin WITH EleAct, LinAct
      DO CASE
         CASE i = escape_ .OR. i = CtrlW
            Sigue  = No
            UltTecla = i
         CASE i = Enter .OR. i = Abajo
            IF EleAct < MaxEle
               EleAct = EleAct + 1
               LinAct = LinAct + 1
            ELSE
               **
               IF TotEle > MAXELE
                  NumEle = MaxEle
                  DO &InsLin WITH NumEle, Ok
                  IF Ok
                     EleAct = EleAct + 1
                     LinAct = LinAct + 1
                     MaxEle = MaxEle + 1
                     FLGins = Si
                     LeeReg = Si
                  ELSE
                     ?? CHR(7)
                  ENDIF
               ELSE
                  ?? CHR(7)
               ENDIF
            ENDIF
            IF LinAct > LinFin
               EleIni = EleIni + LinPan      && Pantalla siguiente.
               EleAct = EleIni
               LinAct = LinIni
               ActPan = Si
            ENDIF
         CASE i = Arriba .AND. EleAct > EleIni
            DO &EscLin WITH EleAct, LinAct
            EleAct = EleAct - 1
            LinAct = LinAct - 1
      ENDCASE
   ELSE
      * - Imprime la l¡nea activa en video inverso.
**      SET STEP ON 
      SET COLOR OF SCHEME 24 TO SCHEME 1
      SET COLOR OF SCHEME 1  TO SCHEME 7
      DO &EscLin WITH EleAct, LinAct
      SET COLOR OF SCHEME 1  TO SCHEME 24
      i = 0
      DO WHILE  .NOT. ( CHR(i)$CURSOR )
         i = INKEY()
         i = IIF( i = F10 , CtrlW , i )
         i = IIF( i >0 .AND. i<256 , i , 0)
      ENDDO
      DO CASE
         CASE i = escape_ .OR. i = CtrlW
            Sigue   = No
            IF ! Empty(PrgFin)
               DO &PrgFin
            ENDIF
            UltTecla = i
         CASE i = Home
            DO &EscLin WITH EleAct, LinAct
            ActPan = EleIni>1
            EleIni = 1
            EleAct = EleIni
            LinAct = LinIni
         CASE i = End
            DO &EscLin WITH EleAct, LinAct
            ActPan = EleIni
            EleIni = MaxEle - MOD(MaxEle-1,LinPan)
            EleAct = MaxEle
            LinAct = LinIni+MOD(MaxEle-1,LinPan)
            ActPan = EleIni<>ActPan
         CASE i = Abajo .AND. EleAct <= MaxEle .AND. EleAct < TotEle
            LinIns = (EleAct = MaxEle)
            IF LinAct >= LinFin
               EleIni = EleIni + LinPan      && Pantalla siguiente.
               EleAct = EleIni
               LinAct = LinIni
               ActPan = Si
            ELSE
               DO &EscLin WITH EleAct, LinAct
               IF EleAct < MaxEle
                  EleAct = EleAct + 1
                  LinAct = LinAct + 1
               ENDIF
            ENDIF
            IF LinIns
               IF TotEle > MAXELE
                  NumEle = MaxEle
                  DO &InsLin WITH NumEle, Ok
                  IF Ok
                     MaxEle = MaxEle + 1
                     FLGins = Si
                     IF EleAct+1 <= MaxEle
                        EleAct = EleAct + 1
                        LinAct = LinAct + 1
                     ENDIF
                     LeeReg = Si
                  ELSE
                     ActPan = No
                     ?? CHR(7)
                  ENDIF
               ELSE
                  ActPan = No
                  ?? CHR(7)
               ENDIF
            ENDIF
         CASE i = Arriba
            IF EleAct > EleIni
               DO &EscLin WITH EleAct, LinAct
               EleAct = EleAct - 1
               LinAct = LinAct - 1
            ELSE
               IF EleIni > 1
                  EleIni = EleIni - LinPan      && Pantalla anterior.
                  EleAct = EleIni + LinPan - 1
                  LinAct = LinIni + LinPan - 1
                  ActPan = Si
               ENDIF
            ENDIF
         CASE i = PgDn .AND. (MaxEle-EleIni) >= LinPan
            EleIni = EleIni + LinPan      && Pantalla siguiente.
            EleAct = EleIni
            LinAct = LinIni
            ActPan = Si
         CASE i = PgUp .AND. EleIni > 1
            EleIni = EleIni - LinPan      && Pantalla anterior.
            EleAct = EleIni
            LinAct = LinIni
            ActPan = Si
         CASE i = Ins
            IF TotEle > MAXELE
               DO &InsLin WITH EleAct-1, Ok
               IF Ok
                  MaxEle = MaxEle + 1        && Aumenta el n£mero de elementos.
                  ActPan = Si
                  LeeReg = Si
                  FLGins = Si
               ELSE
                  ?? CHR(7)
               ENDIF
            ELSE
               ?? CHR(7)
            ENDIF

         CASE ( i = Del )  && .AND. MaxEle > 1
            DO &BrrLin WITH EleAct-1, Ok
            IF Ok
               MaxEle = MaxEle - 1        && Disminuye el n£mero de elementos.
               IF EleAct > MaxEle .AND. MaxEle > 0
                  EleAct = EleAct - 1
                  LinAct = LinAct - 1
               ENDIF
               IF EleAct < EleIni
                  EleIni = EleIni - LinPan      && Pantalla anterior.
                  EleAct = EleIni + LinPan - 1
                  LinAct = LinFin
               ELSE
                  RepPan = Si
               ENDIF
               ActPan = Si
            ELSE
               ?? CHR(7)
            ENDIF
         CASE i = Enter
            LeeReg = Si                && Leer el registro activo.
         OTHERWISE
            ?? CHR(7)
      ENDCASE
   ENDIF
ENDDO .NOT. Sigue
RETURN
********************************************************************** EOP
function rec_lock
*****************
PARAMETERS dWait
PRIVATE ForEver,Orig,Temp
Si      = .T.
No      = .F.
Orig    = dWait
ForEver = (Orig = 0)
Ok      = Si
SAVE SCREEN TO Temp  && Guarda la Pantalla
IF ForEver
   @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
ENDIF
DO WHILE .T.
   IF .NOT. RLOCK()
      Delay=100             &&
      DO WHILE Delay > 0    && Retardo de 1/2 Segundo
         Delay = Delay-1    &&
      ENDDO                 &&
      dWait = dWait - 1
      IF .NOT. (ForEver .or. dWait > 0)
         ?? CHR(7)
         @  7 ,26 say ".-------------------------."  COLOR SCHEME 7
         @  8 ,26 say "|   Registro Protegido    |"  COLOR SCHEME 7
         @  9 ,26 say "|    por  otro Usuario    |"  COLOR SCHEME 7
         @ 10 ,26 say "|(A)bandonar  (R)eintentar|"  COLOR SCHEME 7
         @ 11 ,26 say "`-------------------------'"  COLOR SCHEME 7
         Tecla = 0
         DO WHILE .NOT. CHR(Tecla)$"rRaA"
            Tecla    = INKEY(0)
            Tecla     = IIF(Tecla<0 .OR. Tecla>255,0,Tecla)
         ENDDO
         RESTORE SCREEN FROM Temp
         IF CHR(Tecla)$"Aa"
            Ok     = No
            EXIT
         ELSE
            @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
         ENDIF
         dWait    =  Orig
      ENDIF
   ELSE
      Ok     = Si
      EXIT
   ENDIF
ENDDO
* ------------------------------------------------------------------------
RESTORE SCREEN FROM Temp               && Reponemos la pantalla.
RETURN Ok
PARAMETERS dWait
PRIVATE ForEver,Orig,Temp
Si      = .T.
No      = .F.
Orig    = dWait
ForEver = (Orig = 0)
Ok      = Si
SAVE SCREEN TO Temp                    && Guarda la Pantalla
IF ForEver
   @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
ENDIF
DO WHILE .T.
   IF .NOT. FLOCK()
      Delay=100             &&
      DO WHILE Delay > 0    && Retardo de 1/2 Segundo
         Delay = Delay-1    &&
      ENDDO                 &&
      dWait = dWait - 1
      IF .NOT. (ForEver .or. dWait > 0)
         ?? CHR(7)
         @  7 ,26 say "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿"  COLOR SCHEME 7
         @  8 ,26 say "³    Archivo Protegido    ³"  COLOR SCHEME 7
         @  9 ,26 say "³    por  otro Usuario    ³"  COLOR SCHEME 7
         @ 10 ,26 say "³(A)bandonar  (R)eintentar³"  COLOR SCHEME 7
         @ 11 ,26 say "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ"  COLOR SCHEME 7
         Tecla = 0
         DO WHILE .NOT. CHR(Tecla)$"rRaA"
            Tecla    = INKEY(0)
            Tecla     = IIF(Tecla<0 .OR. Tecla>255,0,Tecla)
         ENDDO
         RESTORE SCREEN FROM Temp
         IF CHR(Tecla)$"Aa"
            Ok     = No
            EXIT
         ELSE
            @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
         ENDIF
         dWait    =  Orig
      ENDIF
   ELSE
      Ok     = Si
      exit
   ENDIF
ENDDO
* ------------------------------------------------------------------------
RESTORE SCREEN FROM Temp               && Reponemos la pantalla.
RETURN Ok
*!*********************************************************************
*!
*!      Procedure: Lib_Mtec
*!
*!*********************************************************************
PROC LIB_MTEC
PARAMETERS nEstado
PRIVATE cMsgKey, cTextKey, nPos, nColumn
cMsgKey = ""
DO CASE
   CASE TYPE("nEstado") = "C"
      cMsgKey = nEstado
   CASE TYPE("nEstado") # "N"
   CASE nEstado = 0
   CASE nEstado = 1
      cMsgKey = "[Esc] Salir   [Enter] Selecciona   [PgUp] Anterior   [PgDn] Siguiente   [F8] Consulta"
   CASE nEstado = 2
      cMsgKey = "[Esc] Salir  [Enter] Editar  [F9] Borrar  [PdUp] Anterior  [PgDn] Siguiente  [F8] Consulta"
   CASE nEstado = 3
      cMsgKey = "[Esc] Salir   [Enter] Editar    [PgUp] Anterior  [PgDn] Siguiente    [End] Pide Llave"
   CASE nEstado = 4
      cMsgKey = "[Esc] Salir   [PgUp] Anterior   [PgDn] Siguiente"
   CASE nEstado = 5
      cMsgKey = "[Esc] Salir   [Enter] Consultar    [F6] Listar"
   CASE nEstado = 6
      cMsgKey = "[Esc] Salir   [Enter] Consultar"
   CASE nEstado = 7
      cMsgKey = "[Esc] Cancelar [Enter] Aceptar [Tab] Sig.Campo [S-Tab] Ant.Campo [F8] Consulta [F10] Grabar"
   CASE nEstado = 8
      cMsgKey = "[Esc] Salir   [Enter] Seleccionar"
   CASE nEstado = 9
      cMsgKey = "[Esc] Salir  [F10] Graba  [Enter] Edita   [Ins] Inserta   [Del] Borra"
   CASE nEstado = 10
      cMsgKey = "[Esc] Salir   [^W] Graba   [PgUp] Anterior    [PgDn] Siguiente"
   CASE nEstado = 11
      cMsgKey = "[Esc] Salir   [Enter] Registrar   [F8] Consultar  [F10] Grabar"
   CASE nEstado = 12
      cMsgKey = "[Esc] Salir   [Enter] Registrar   [<-] [->] Seleccionar"
   CASE nEstado = 13
      cMsgKey = "[Esc] Salir   [Enter] Registrar   [Up] Campo Anterior"
   CASE nEstado = 14
      cMsgKey = "[] [] [PgUp] [PgDw] [Home] [End] Posiciona  [Del] Elimina [Ins] Ins. [Enter] Ingreso  [F10] Salir"
   CASE nEstado = 15
      cMsgKey = "[] [] [PgUp] [PgDw] [Home] [End] Posiciona  [Del] Elimina   [F10] Salir"
   CASE nEstado = 16
      cMsgKey = "[<-] [->] Selecciona    [Esc] Salir   [Enter] Registrar"
   CASE nEstado = 17
      cMsgKey = "[F1] Sorteo     [F2] Posicionar    [F3] Localizar    [F4] Siguiente"

   CASE Type( "GsMsgKey" ) = "C"
      cMsgKey = GsMsgKey
ENDCASE
cMsgKey  = LTrim(Trim(cMsgKey))
cTextKey = cMsgKey
DO WHILE "[" $ cTextKey .OR. "]" $ cTextKey
   cTextKey = Stuff(cTextKey , AT("[", cTextKey), 1, "")
   cTextKey = Stuff(cTextKey , AT("]", cTextKey), 1, "")
ENDDO
IF Len( cTextKey ) > WCOLS()
   cTextKey = LEFT(cTextKey, WCOLS())
ENDIF
nColumn  = Int((WCOLS() - Len(cTextKey))/2)
IF _WINDOWS OR _MAC
	@ WROWS()-3,0 CLEAR TO WROWS()-2,WCOLS()
	@ WROWS()-3,nColumn SAY cTextKey && FONT 'Foxfont',6
ELSE
	@ 24,0 CLEAR to 24,79
	@ 24,nColumn SAY cTextKey
ENDIF
Do While At( "[", cMsgKey ) > 0
   nPos    = At( "[", cMsgKey )
   nColumn = nColumn + (nPos - 1)
   cMsgKey = Right( cMsgKey, Len(cMsgKey) - nPos )
   nPos    = At("]", cMsgKey )
   if nPos = 0
      nPos = Len(cMsgKey)
   else
      nPos = nPos - 1
   endif
   cTextKey = Left( cMsgKey, nPos )
   DO WHILE "[" $ cTextKey .OR. "]" $ cTextKey
      cTextKey = Stuff(cTextKey , AT("[", cTextKey), 1, "")
   ENDDO
   cMsgKey =  Right( cMsgKey, Len(cMsgKey)-nPos )
   IF nColumn + (Len( cTextKey )-1) > (WCOLS()-1)
      EXIT
   ENDIF
   IF _WINDOWS OR _MAC
	   @ WROWS()-3, nColumn GET cTextKey && FONT 'Foxfont',6
   ELSE
	   @ 24, nColumn GET cTextKey
   ENDIF
   nColumn = nColumn + (Len( cTextKey )-1)
ENDDO
CLEAR GETS
RETURN
******************
procedure admprint
******************
PARAMETERS XTipRep
PRIVATE OPC,DBF,SELECT,REGACT
ACTIVATE SCREEN
SET TALK OFF
IF TYPE("XWHILE") <> "C"
   XWHILE   = ""
ENDIF
IF TYPE("XFOR") <> "C"
   XFOR     = ""
ENDIF
IF TYPE("INIPRN") <> "C"
   INIPRN   = ""
ENDIF

IF TYPE("XTipRep") = "C"
   IF  XTipRep = "REPORTS" .OR. XTipRep = "QUERY" .OR. XTipRep = "LABEL"
      IF  XTipRep = "LABEL"
         ON KEY LABEL CTRL+R MODIFY LABEL   (sNomRep) NOENVIRONMENT
      ELSE
         ON KEY LABEL CTRL+R MODIFY REPORT  (sNomRep) NOENVIRONMENT
      ENDIF
      IF  XTipRep = "QUERY"
         ON KEY LABEL CTRL+Q MODIFY QUERY   (sNomQry)
      ENDIF
  ENDIF
ENDIF
SAVE SCREEN
@ 16,1 CLEAR TO 24,79
@ 17,0,24,78 BOX "°    °°°" COLOR N+/W
@ 16,1 TO 23,79 COLOR SCHEME 5
@ 16,1 FILL TO 23,79 COLOR SCHEME 5

@ 23,21 SAY "´ Presione [F10] para continuar Ã" COLOR SCHEME 7
_PCOPIES = 1
_PBPAGE  = 1
_PEPAGE  = 32767
_PAGENO  = 1
_PWAIT   = .F.
_PSELECT = .F.
_DESTINO = 1
_PEJECT  = "NONE"
M.OPC    = 0

IF ! FILE("admprint.dbf")
   _COMANDO   = ""
   _Interface = ""
   _Driver    = "Epson.pdt"
   _NOMBRE    = "Impresora Local                 "
ENDIF
_Archivo = SPACE(30)
M.DBF    = DBF()
M.SELECT = SELECT()
M.REGACT = RECNO()
@ 17,3 TO 22,30 COLOR SCHEME 5
@ 18,7  SAY "N£mero de Copias :"  COLOR SCHEME 5
@ 17,6  SAY "Control de Impresi¢n" COLOR SCHEME 7
@ 17,33 GET _Destino PICTURE "@*RVN \<Impresora;\<Pantalla;\<Archivo" DEFAULT 1  COLOR SCHEME 5
@ 19,54 GET _ARCHIVO SIZE 1,19 PICTURE "@K!" WHEN _DESTINO = 3  COLOR SCHEME 5

@ 18,26 GET _PCOPIES RANGE 1, 32767   PICTURE "##"     COLOR SCHEME 5
@ 19,6  GET _PWAIT PICTURE "@*C Pa\<usa entre P ginas"  COLOR SCHEME 5

@ 20,7  SAY "P ginas  del :" COLOR SCHEME 5
@ 21,17 SAY "al :" COLOR SCHEME 5
@ 20,24 GET _PBPAGE RANGE 1, _PEPAGE  PICTURE "#####" COLOR SCHEME 5
@ 21,24 GET _PEPAGE RANGE 1, 32767    PICTURE "#####" COLOR SCHEME 5

@ 20,31 TO 22,78 COLOR SCHEME 5
IF FILE("admprint.dbf")
   @ 21,32 GET _PSELECT PICTURE "@*C I\<nterface" VALID PSELECT() COLOR SCHEME 5
ENDIF
@ 21,46 SAY "[                              ]" COLOR SCHEME 5
@ 21,47 SAY _NOMBRE PICTURE "@S30" COLOR SCHEME 5
READ CYCLE
RESTORE SCREEN
SELECT (M.SELECT)
IF RECNO() <> M.REGACT .AND. ! EMPTY(M.DBF)
   GOTO M.REGACT
ENDIF

ON KEY LABEL CTRL+R
ON KEY LABEL CTRL+Q
DO CASE
   CASE _Destino = 1
      IF EMPTY(_Interface )
         SET PRINTER TO LPT1
      ELSE
         SET PRINTER TO (_Interface)
      ENDIF
      RESTORE FROM (_Driver) ADDITIVE
   CASE _Destino = 2
      _Archivo = PathUser+sys(3)+".pat"
      DELETE FILE (_Archivo)
      SET PRINTER TO (_ARCHIVO)
      STORE "" TO _Prn0,_Prn1,_Prn2,_Prn3,_Prn4,_Prn5a,_Prn5b,_Prn6a,_Prn6b,;
                  _Prn7a,_Prn7b,_Prn8a,_Prn8b,_Prn9a,_Prn9b
   CASE _Destino = 3
      IF "" = TRIM(_ARCHIVO)
         _Archivo = PathUser+sys(3)+".prn"
      ENDIF
      IF ! "."$_ARCHIVO
         _Archivo = _Archivo+".prn"
      ENDIF
      IF ! ( ":"$_ARCHIVO OR  "\"$_ARCHIVO OR  "/"$_ARCHIVO)
         _Archivo = PathUser+_Archivo
      ENDIF
      DELETE FILE (_Archivo)
      SET PRINTER TO (_ARCHIVO)
      RESTORE FROM (_Driver) ADDITIVE
ENDCASE
IF LASTKEY() = 27
   RETURN
ENDIF
@ 19,19 FILL TO 22,60 COLOR SCHEME 11
@ 19,19 TO 22,60      COLOR SCHEME 11
@ 20,20 SAY " *****   En proceso de Impresi¢n  ***** " COLOR SCHEME 11
@ 21,20 SAY " Presione [ESC] para cancelar Impresi¢n " COLOR SCHEME 11
@ 21,31 SAY "ESC" COLOR SCHEME 7
SET CONSOLE OFF
IF TYPE("XTipRep") = "C" AND LASTKEY() # 27
   IF _Destino <> 2
      IF EMPTY(_Interface)
         set printer to LPT1
      ELSE
         set printer to (_interface)
      ENDIF
      ??? &IniPrn
   ENDIF
   SET ESCAPE ON
   ON  ESCAPE RETURN
   IF XTipRep = "REPORTS"
      DO FORMREPO   &&IN ADMPRINT
   ENDIF
   IF XTipRep = "QUERY"
      SET TALK ON
      SET TALK WINDOW
      IF ! ".QPR"$sNomQry
         sNomQry = sNomQry+".QPR"
      ENDIF
      DO  (sNomQry)
      SET TALK OFF
      DO FORMREPO   &&IN ADMPRINT
   ENDIF
   IF XTipRep = "LABEL"
      DO FORMLABE   &&IN ADMPRINT
   ENDIF
   DO ADMPRFIN  &&IN ADMPRINT
ENDIF
RETURN


******************
PROCEDURE DIRPRINT
******************
PARAMETERS XTipRep
PRIVATE OPC,DBF,SELECT,REGACT
ACTIVATE SCREEN
SET TALK OFF
IF TYPE("XWHILE") <> "C"
   XWHILE   = ""
ENDIF
IF TYPE("XFOR") <> "C"
   XFOR     = ""
ENDIF
IF TYPE("INIPRN") <> "C"
   INIPRN   = "CHR(0)"
ENDIF

IF TYPE("XTipRep") = "C"
   IF  XTipRep = "REPORTS" .OR. XTipRep = "QUERY" .OR. XTipRep = "LABEL"
      IF  XTipRep = "LABEL"
         ON KEY LABEL CTRL+R MODIFY LABEL   (sNomRep) NOENVIRONMENT
      ELSE
         ON KEY LABEL CTRL+R MODIFY REPORT  (sNomRep) NOENVIRONMENT
      ENDIF
      IF  XTipRep = "QUERY"
         ON KEY LABEL CTRL+Q MODIFY QUERY   (sNomQry)
      ENDIF
  ENDIF
ENDIF
_PCOPIES = 1
_PBPAGE  = 1
_PEPAGE  = 32767
_PAGENO  = 1
_PWAIT   = .F.
_PSELECT = .F.
_DESTINO = 1
_PEJECT  = "NONE"

IF ! FILE("admprint.dbf")
   _COMANDO   = ""
   _Interface = ""
   _Driver    = "Epson.pdt"
   _NOMBRE    = "Impresora Local                 "
ENDIF
_Archivo = SPACE(30)
M.DBF    = DBF()
M.SELECT = SELECT()
M.REGACT = RECNO()
M.OPC    = 1
SAVE SCREEN
@ 20,19 FILL TO 23,59 COLOR W+/N
@ 19,20 CLEAR TO 22,60
@ 19,20 FILL TO 22,60 COLOR SCHEME 5
@ 19,20 TO 22,60 COLOR SCHEME 5
@ 20,22 SAY "Presione       para iniciar impresi¢n" COLOR SCHEME 5
@ 20,31 GET Opc PICT "@*HT F10" COLOR SCHEME 5
@ 21,26 SAY "[                              ]" COLOR SCHEME 5
@ 21,27 SAY _NOMBRE PICTURE "@S30" COLOR SCHEME 5
@ 21,22 GET _PSELECT PICTURE "@*C" VALID PSELECT() COLOR SCHEME 5
READ CYCLE
RESTORE SCREEN
SELECT (M.SELECT)
IF RECNO() <> M.REGACT .AND. ! EMPTY(M.DBF)
   GOTO M.REGACT
ENDIF

ON KEY LABEL CTRL+R
ON KEY LABEL CTRL+Q
DO CASE
   CASE _Destino = 1
      IF EMPTY(_Interface)
         SET PRINTER TO LPT1
      ELSE
         SET PRINTER TO (_Interface)
      ENDIF
      RESTORE FROM (_Driver) ADDITIVE
ENDCASE
IF LASTKEY() = 27
   RETURN
ENDIF
@ 19,19 FILL TO 22,60 COLOR SCHEME 11
@ 19,19 TO 22,60      COLOR SCHEME 11
@ 20,20 SAY " *****   En proceso de Impresi¢n  ***** " COLOR SCHEME 11
@ 21,20 SAY " Presione [ESC] para cancelar Impresi¢n " COLOR SCHEME 11
@ 21,31 SAY "ESC" COLOR SCHEME 7
SET CONSOLE OFF
IF TYPE("XTipRep") = "C" AND LASTKEY() # 27
   IF _Destino <> 2
      set printer to (_interface)
      ??? &IniPrn
   ENDIF
   SET ESCAPE ON
   ON  ESCAPE RETURN
   IF XTipRep = "REPORTS"
      DO FORMREPO  &&IN ADMPRINT
   ENDIF
   IF XTipRep = "QUERY"
      SET TALK ON
      SET TALK WINDOW
      DO  (sNomQry)
      SET TALK OFF
      DO FORMREPO  && IN ADMPRINT
   ENDIF
   IF XTipRep = "LABEL"
      DO FORMLABE  &&IN ADMPRINT
   ENDIF
   DO ADMPRFIN   &&IN ADMPRINT
ENDIF
RETURN


*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                 PSELECT  SELCCION DE IMPRESORA          º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
FUNC PSELECT
PRIVATE LsNulo,m.currsel,LinReg,Ancho,Xo
m.currsel = SELECT()
_PSelect   = .F.
IF ! USED("admprint")
   SELECT 0
   USE ADMPRINT ORDER ADMPRINT
ELSE
   SELECT admprint
ENDIF
SEEK GsTerminal
IF ! FOUND()
   SELECT (m.currsel)
   RETURN .T.
ENDIF
DEFINE WINDOWS MODULOS FROM 9,74-(LEN(admprint.Nombre));
      TO 24,77 NONE   COLOR SCHEME 10
BROWSE FIELD admprint.Nombre KEY GsTerminal NODELETE NOAPPEND NOMODIFY NOMENU;
       TITLE "IMPRESORAS" WINDOWS MODULOS
RELEASE WINDOWS MODULOS
IF LASTKEY() # 27
   _Nombre    = Nombre
   _Comando   = Comando
   _Interface = Interface
   _Driver    = TRIM(Driver)+".pdt"
   IF ! EMPTY(Comando)
      ! &_Comando >NUL
   ENDIF
   IF M.OPC = 0
      @ 21,47 SAY _NOMBRE PICTURE "@S30" COLOR SCHEME 5
   ELSE
      @ 21,27 SAY _NOMBRE PICTURE "@S30" COLOR SCHEME 5
   ENDIF
ENDIF
RETURN .T.
*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
PROC FORMREPO
IF EOF()
   RETURN
ENDIF
M.REGACT = RECNO()
PRINTJOB
   GOTO M.REGACT
   DO CASE
      CASE XWHILE == "" AND XFOR == ""
         REPORT REST FORM (sNomRep) NOEJECT PDSETUP TO PRINT
      CASE XWHILE == ""
         REPORT REST FORM (sNomRep) NOEJECT PDSETUP TO PRINT ;
              FOR EVALUATE(XFOR)
      CASE XFOR == ""
         REPORT REST FORM (sNomRep) NOEJECT PDSETUP TO PRINT ;
              WHILE EVALUATE(XWHILE)
      OTHER
         REPORT REST FORM (sNomRep) NOEJECT PDSETUP TO PRINT ;
              WHILE EVALUATE(XWHILE) FOR EVALUATE(XFOR)
   ENDCASE
ENDPRINTJOB
RETURN

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
PROC FORMLABE
IF EOF()
   RETURN
ENDIF
M.REGACT = RECNO()
PRINTJOB
   GOTO M.REGACT
   DO CASE
      CASE XWHILE == "" AND XFOR == ""
         LABEL  REST FORM (sNomRep) PDSETUP TO PRINT
      CASE XWHILE == ""
         LABEL  REST FORM (sNomRep) PDSETUP TO PRINT ;
              FOR EVALUATE(XFOR)
      CASE XFOR == ""
         LABEL  REST FORM (sNomRep) PDSETUP TO PRINT ;
              WHILE EVALUATE(XWHILE)
      OTHER
         LABEL  REST FORM (sNomRep) PDSETUP TO PRINT ;
              WHILE EVALUATE(XWHILE) FOR EVALUATE(XFOR)
   ENDCASE
ENDPRINTJOB
RETURN

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                 ADMPRFIN Fin de Impresi¢n               º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
PROC ADMPRFIN
PRIVATE Respuesta
ON  ESCAPE
SET PRINTER TO
SET ESCAPE OFF
SET CONSOLE ON
SET DEVICE TO SCREEN
DO CASE
   CASE _Destino = 2
      **RUN README &_Archivo
      MODI COMM (_aRCHIVO)
      DELETE FILE (_ARCHIVO)
   CASE _Destino = 3
      **RUN README &_Archivo
      MODI COMM (_aRCHIVO)

      @ 20,19 CLEAR TO 22,60
      @ 20,19 TO 22,60
      Respuesta = 1
      @ 21,25 GET Respuesta PICTURE "@*HT \<Salir;\<Borrar;\<Imprimir"
      READ CYCLE
      DO CASE
         CASE Respuesta = 2
            DELETE FILE (_Archivo)
         CASE Respuesta = 3
            SET HEADING OFF
            SET CONSOLE OFF
            SET PDSETUP TO
            _PEJECT = "NONE"
            TYPE (_Archivo) TO PRINT
            SET CONSOLE ON
            SET HEADING ON
            *DELETE FILE (_Archivo)
      ENDCASE
ENDCASE
RETURN

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                 ADMMBPRN Membrete de Impresi¢n          º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
**************************************************************************
* Definir las siguientes variables antes de correr esta opci¢n :         *
* Titulo    -->  Titulo                                                  *
* SubTitulo -->  Sub Titulo                                              *
* NumPag    -->  contador de p ginas                                     *
* NumLin    -->  contador de l¡neas de impresi¢n                         *
* E1..E9    -->  Encabezados de impresi¢n                                *
* Ancho     -->  Ancho de la Impresi¢n                                   *
* IniImp    -->  Setup de Impresi¢n                                      *
**************************************************************************
PROCEDURE ADMMBPRN
******************
IF NumPag > 0
   EJECT PAGE
ENDIF
NumPag    = _PAGENO
IF NumPag = 1 .OR. NumPag = _PEPAGE
   IF ! GlRunDos
      SET PRINTER TO "cat >/dev/null"
   ELSE
      SET PRINTER TO NUL
   ENDIF
ENDIF

IF NumPag = _PBPAGE   && Reset Printer
   DO CASE
      CASE _Destino = 1
         IF EMPTY(_Interface)
            SET PRINTER TO LPT1
         ELSE
            SET PRINTER TO (_Interface)
         ENDIF
      CASE _Destino = 2
         SET PRINTER TO (_ARCHIVO)
      CASE _Destino = 3
         SET PRINTER TO (_ARCHIVO)
   ENDCASE
   @ 0,0 SAY _PRN0+IIF(_PRN5A==[],[],_PRN5a+CHR(Largo)+_PRN5b)
ENDIF

UltTecla = 0
IF NumPag >= _PBPAGE
   IF  _PWAIT
      SET DEVICE TO SCREEN
      @ 20,20 say "           Pausa entre p ginas          " COLOR SCHEME 7
      @ 21,20 say "     Presione [Enter] para continuar    " COLOR SCHEME 7
      ?? CHR(7)
      @ 21,35 say "Enter" COLOR W*/N
      UltTecla = 0
      DO WHILE ! (UltTecla = Enter .OR. UltTecla = Escape)
         UltTecla = INKEY(0)
      ENDDO
      IF UltTecla = Escape
         SET DEVICE TO PRINTER
         RETURN
      ENDIF
      @ 20,20 say "                                        "    COLOR SCHEME 11
      @ 20,25 say "Imprimiendo  la P gina No. "+STR(NumPag,3,0) COLOR SCHEME 11
      @ 21,20 SAY " Presione [ESC] para cancelar Impresi¢n "    COLOR SCHEME 11
      SET DEVICE TO PRINTER
   ENDIF
ENDIF
IF GlRunDos
   SET DEVICE TO SCREEN
   @ 20,20 say "                                        "    COLOR SCHEME 11
   @ 20,25 say   "Imprimiendo  la P gina No. "+STR(NumPag,3,0) COLOR SCHEME 11
   SET DEVICE TO PRINTER
ENDIF

ColTit = (Ancho - LEN(Titulo) - 1)/2
ColSTt = (Ancho - LEN(SubTitulo) - 1)/2
MrgIzq = (Ancho - LEN(En9) - 1)/2
ColDer =  Ancho - LEN(Tit_Sder) - 1

* - Imprimir el encabezado de la p gina.
NumLin = 0
   @ NumLin,0      SAY IniImp
   @ NumLin,0      SAY GsNomCia
   DO CASE
      CASE Titulo="@"
         IF _Destino <> 3
            ColTit = (Ancho - 2*(LEN(Titulo)-1) - 1)/2
         ENDIF
         @ NumLin,ColTit SAY Prn7b+SUBSTR(Titulo,2)+_Prn7b
         IF _Destino <> 3
            @ NumLin,0 SAY ""
         ENDIF
      OTHER
         @ NumLin,ColTit SAY Titulo
   ENDCASE
   @ NumLin,ColDer SAY Tit_Sder

NumLin = NumLin + 1
   @ NumLin,0        SAY GsDirCia
   DO CASE
      CASE Titulo="@"
         IF _Destino <> 2
            ColSTt = (Ancho - 2*(LEN(SubTitulo)-1) - 1)/2
         ENDIF
         @ NumLin,ColSTt SAY _Prn7b+SUBSTR(SubTitulo,2)+_Prn7b
         IF _Destino <> 2
            @ NumLin,0 SAY ""
         ENDIF
      OTHER
         @ NumLin,ColSTt   SAY SubTitulo
   ENDCASE
   @ NumLin,Ancho-14 SAY "PAGINA: "+STR(NumPag,5)

Lin      = 1
DO WHILE Lin <= 9
   i          = STR(Lin,1,0)
   Leyenda    = En&I
   IF LEN(Leyenda) > 0
      NumLin = NumLin + 1
      DO CASE
         CASE Leyenda = "<"
            Leyenda    = RIGHT( Leyenda, LEN(Leyenda)-1)
            Col = 0
         CASE Leyenda = "@"
            Col    = (Ancho - LEN(Leyenda) - 1)/2
            IF _Destino <> 2
               Col    = (Ancho - 2*(LEN(Leyenda)-1) - 1)/2
            ENDIF
            Leyenda    = _Prn7a+SUBST( Leyenda, 2)+_Prn7b
         OTHER
            Col    = (Ancho - LEN(Leyenda) - 1)/2
      ENDCASE
      IF Col < 0
         Col  = 0
      ENDIF
      XXLEN = LEN(Leyenda)
      IF XXLEN <= 254
         @ NumLin,Col SAY Leyenda
      ELSE
         XX = LEFT(Leyenda,254)
         XY = SUBS(Leyenda,255)
         @ NumLin,Col     SAY XX
         @ NumLin,Col+254 SAY XY
      ENDIF
   ENDIF
   Lin        = Lin + 1
ENDDO
RETURN

*****************
procedure dbrowse
*****************
PRIVATE    Finalizar,Ejecutar,Movilizar,Cursor,FKey
PRIVATE    dBTemp,Y1,X1,MaxLin,Ultimo,LinIni,Refresco,Rst
PRIVATE    LinFin,Actual,Si,No,Fin,Contenido
PRIVATE    SetCursor,Set_Append,SetFin
PRIVATE    Listar,RegVal,Sigue,LinTmp,CT,CB,j,dB_top,dB_Bottom
PRIVATE    HAYSELLIN,HAYEDILIN,HAYBRRLIN,HAYINSLIN,HAYGRBLIN
PRIVATE    HAYESCLIN
PRIVATE    VClave1,VClave2,RegPxm,Len1,Len2
PRIVATE    Msg1,Msg2,NumReg,MsgAdd
IF _UNIX OR _DOS
	ACTIVATE SCREEN
ELSE

ENDIF	
IF .NOT. TYPE("PrgFin")="C"
   PRIVATE PrgFin
   PrgFin = []
ENDIF

IF .NOT. TYPE("EscLin")="C"
   PRIVATE EscLin
   EscLin = []
ENDIF

IF .NOT. TYPE("TstImp")="C"
   PRIVATE TstImp
   TstImp = []
ENDIF

IF .NOT. TYPE("Set_Escape")="L"
   PRIVATE Set_Escape
   Set_Escape = .F.
ENDIF

IF .NOT. TYPE("Set_Pinta")="L"
   PRIVATE Set_Pinta
   Set_Pinta  = .T.
ENDIF

HAYSELLIN = IIF("" <> TRIM(SelLin), .T., .F.)
HAYESCLIN = IIF("" <> TRIM(EscLin), .T., .F.)
HAYEDILIN = IIF("" <> TRIM(EdiLin), .T., .F.)
HAYBRRLIN = IIF("" <> TRIM(BrrLin), .T., .F.)
HAYINSLIN = IIF("" <> TRIM(InsLin), .T., .F.)
HAYGRBLIN = IIF("" <> TRIM(GrbLin), .T., .F.)
HAYPRGFIN = IIF("" <> TRIM(PrgFin), .T., .F.)

PRIVATE     Linea
PRIVATE     NumRg

DIMENSION  Linea(Largo-2), NumRg(Largo-2)        && FoxBase +

?? SYS(2002)
IF Static
   SAVE SCREEN TO dBTemp                  && Graba pantalla actual.
ENDIF

FKey    = STR(F10,3,0)+"|"
FKey    = FKey + IIF(MvPrgF1 == [] ,  [], STR(F1,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF2 == [] ,  [], STR(F2,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF3 == [] ,  [], STR(F3,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF4 == [] ,  [], STR(F4,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF5 == [] ,  [], STR(F5,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF6 == [] ,  [], STR(F6,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF7 == [] ,  [], STR(F7,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF8 == [] ,  [], STR(F8,3,0)+"|"  )
FKey    = FKey + IIF(MvPrgF9 == [] ,  [], STR(F9,3,0)+"|"  )

Finalizar = IIF(Consulta,CHR(escape_),CHR(CtrlW))
IF Set_Escape
   Finalizar = Finalizar + CHR(escape_)
ENDIF

Ejecutar  = IIF(HAYEDILIN .OR. Consulta,CHR(Enter),[]);
            +IIF(HAYINSLIN,CHR(Ins),[])+IIF(HAYBRRLIN,CHR(Del),[])
Movilizar = CHR(Abajo)+CHR(Arriba)+CHR(PgUp)+CHR(PgDn)+CHR(Home)+CHR(End)
Cursor    = Finalizar + Ejecutar + Movilizar

Ultimo    = 0                          && Ultimo registro en la ventana.
Actual    = 1                          && L¡nea activa.
UltTecla  = 0                          && Ultima Tecla Presionada

NumReg    = 0
RegVal    = ""
Si        = .T.
No        = .F.
CT        = " "                        && Indica si hay registros arriba.
CB        = " "                        && Idem, abajo.
MsgAdd    = Si                         && Enviar mensaje de Adicion
dB_Top    = No                         && Indica si hay registros arriba.
dB_Bottom = Si                         && Idem, abajo.
* ------------------------------------------------------------------------
* Dibuja el Marco  -------------------------------------------------------
IF Set_Pinta
   IF VSombra .AND. Xo > 0
      @ Yo+1,Xo-1,Yo+Largo,Xo+Ancho-2 BOX REPLICATE("°",8) COLOR SCHEME 11
     *@ Yo+1,Xo-1,Yo+Largo,Xo+Ancho-2 BOX "Û   ßßßÛ" COLOR SCHEME 11
   ENDIF
   @ Yo+1,Xo+1 CLEAR TO Yo+Largo-2,Xo+Ancho-2
   DO CASE
      CASE TBorde = 0
      CASE TBorde = 2
         @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 DOUBLE
      CASE TBorde = 3
         @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 PANEL
      OTHER
         @ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1
   ENDCASE
   IF ! Titulo == ""
      Col = INT((Ancho-2 - LEN(Titulo))/2)
      Col = iif(Col>0,Col,0)
      @ Yo,Xo + Col SAY LEFT(Titulo,Ancho-2)   COLOR SCHEME 7
   ENDIF
ENDIF
* Dibuja encabezados si existen y mensajes si se indica ------------------
Lin      = 0
IF "" <> E1
   IF Set_Pinta
      @ Yo+1,Xo+1 SAY E1 SIZE 1,Ancho-2 COLOR SCHEME 7
   ENDIF
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF "" <> E2
   IF Set_Pinta
      @ Yo+1,Xo+1 SAY E2 SIZE 1,Ancho-2 COLOR SCHEME 7
   ENDIF
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF "" <> E3
   IF Set_Pinta
      @ Yo+1,Xo+1 SAY E3 SIZE 1,Ancho-2 COLOR SCHEME 7
   ENDIF
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
IF Lin > 0
   IF Set_Pinta
      DO CASE
         CASE TBorde = 0
         CASE TBorde = 2
            @ Yo+1,Xo         SAY "Ç"
            @ Yo+1,Xo+1 TO Yo+1,Xo+Ancho-2
            @ Yo+1,Xo+Ancho-1 SAY "¶"
         CASE TBorde = 3
            @ Yo+1,Xo TO Yo+1,Xo+Ancho-1 PANEL
         OTHER
            @ Yo+1,Xo         SAY "Ã"
            @ Yo+1,Xo+1 TO Yo+1,Xo+Ancho-2
            @ Yo+1,Xo+Ancho-1 SAY "´"
      ENDCASE
   ENDIF
   Yo = Yo + 1
   Lin    = Lin    + 1
ENDIF
*
* ------------------------------------------------------------------------
Y1       = Yo + Largo - 1             && Fila coordenada inferior derecho.
X1       = Xo + Ancho - 1             && Columna inferior derecha.
MaxLin   = Largo-Lin-2                && M ximo de l¡neas a imprimir.
LinIni   = Yo + 1                     && Primera l¡nea £til en ventana.
LinFin   = LinIni + MaxLin - 1        && L¡nea final en la ventana.
Y1       = LinFin                     && Fila coordenada inferior derecho.

* L¢gica principal -------------------------------------------------------
*
* - Lazo principal del sistema, se ejecuta mientras el usuario  no haya
*   cancelado o elegido satisfactoriamente un registro.
*

Sigue     = Si

IF .NOT. TYPE("db_Pinta")="L"
   dB_Pinta  = .F.
ENDIF

DO WHILE Sigue
   *
   * ---------------------------------------------------------------------

   * - Debe actualizar los registros de la ventana.
   Listar   = Si
   dB_Top   = Si
   IF (LEN(TRIM(VClave)) <> 0)
      RegVal   = "&NClave = VClave"
      SEEK VClave
      Set_Append = .NOT. (&RegVal) .AND. Adiciona
   ELSE
      * - Todos los registros son v lidos.
      RegVal = ".T."
      GOTO TOP
      Set_Append = EOF() .AND. Adiciona
   ENDIF
   Fin              = No
   Actual           = 1
   Refresco         = No

   DO WHILE .NOT. Fin
   *
   * ---------------------------------------------------------------------

   * - Lazo de Control de Datos.

      * Imprime pantalla activa ---------------------------------------
      *
      IF Listar
         IF Set_Pinta
            @ Yo+1,Xo+1 CLEAR TO Y1,X1-1
         ENDIF
         LinTmp = LinIni
         DO WHILE (LinTmp <= LinFin) .AND. (&RegVal) .AND. (.NOT.EOF())
            Contenido = []
            IF HayEscLin
               DO &EscLin WITH Contenido
            ELSE
               Contenido  = &LinReg
            ENDIF
            IF Set_Pinta
               @ LinTmp,Xo+2 SAY Contenido
            ENDIF
            LinTmp                = LinTmp + 1
            Linea(LinTmp-LinIni)  = Contenido
            NumRg(LinTmp-LinIni)  = RECNO()
            SKIP
         ENDDO
         Set_Pinta = Si
         dB_bottom= ! ((&RegVal) .AND. (.NOT.EOF()))
         Ultimo = LinTmp - LinIni

         IF Ultimo = 0              && Ning£n registro seleccionado.
             Linea(1) = []
             NumRg(1) = 0
            Set_Append   = Adiciona
         ENDIF

         * - Verificamos si se alcanz¢ el fin de lista.
         IF LinTmp  <= LinFin
             @ LinTmp,Xo+1 SAY "° =o= "+REPLICATE("°",Ancho-8) COLOR SCHEME 7
             Linea(Ultimo+1) = []
             NumRg(Ultimo+1) = 0
         ENDIF
         *
         Listar = No                && Desactiva el listado.
         Actual = IIF(Refresco,IIF(Ultimo<Actual,Ultimo,Actual),1)
         Refresco         = No      && inicilizar a 1 el valor Actual
         IF db_Pinta
            ?? SYS(2002,1)
            CT = IIF(dB_Top    ,"þ","")
            CB = IIF(dB_Bottom ,"þ","")
            @ Yo+1,X1      SAY CT  COLOR SCHEME 7
            @ Y1  ,X1      SAY CB  COLOR SCHEME 7
            RELEASE db_Pinta
            RETURN
         ENDIF
         *
      ENDIF

      * Imprime indicadores de fin e inicio de archivo ----------------
      *
      CT = IIF(dB_Top    ,"þ","")
      CB = IIF(dB_Bottom ,"þ","")
      @ Yo+1,X1      SAY CT COLOR SCHEME 7
      @ Y1  ,X1      SAY CB COLOR SCHEME 7
      *
      *
      * ---------------------------------------------------------------

      IF Set_Append .AND. MsgAdd .AND. Ultimo>0 .AND. ! Consulta
         Msg1 = "Desea Adicionar Registros"
         Msg2 = "(S)i / (N)o"
         Rst=Aviso(20,Msg1,Msg2,[],3,'SN'+CHR(27),0,.T.,.F.,.T.)
         Set_Cursor = Si
         ?? SYS(2002)
         IF Rst <> 'S'
            IF Ultimo>0
               GOTO NumRg(1)
            ELSE
               GOTO TOP
               Listar     = Si
               Refresco   = Si
            ENDIF
            SetFin = No
            Set_Append = No
         ENDIF
      ENDIF
      IF Set_Append .AND. ! Consulta
         MsgAdd    = No
         * Edita la l¡nea activa.
         ?? SYS(2002,1)     && Cursor ON
         UltTecla = 0
         Crear    = Si
         Actual   = IIF( Ultimo > 0 , Ultimo + 1 , 1)
         LinAct = LinIni+Actual-1
         IF Actual > MaxLin
            Actual = MaxLin
            Contenido = []
            IF HayEscLin
               DO &EscLin WITH Contenido
            ELSE
               Contenido  = &LinReg
            ENDIF
            j =1
            DO WHILE j <MaxLin
               Linea(j)  = Linea(j+1)
               NumRg(j)  = NumRg(j+1)
               j =j +1
            ENDDO
            SCROLL Yo+1,Xo+1,Y1,X1-1,+1
            dB_Top = No
         ELSE
            SCROLL LinAct,Xo+1,Y1,X1-1,-1
         ENDIF
         LinAct = LinIni+Actual-1
         DO &EdiLin
         IF UltTecla = 0
            UltTecla = LASTKEY()
         ENDIF
         IF UltTecla <> escape_
            IF HAYGRBLIN
               DO &GrbLin
            ENDIF
            Contenido = []
            IF HayEscLin
               DO &EscLin WITH Contenido
            ELSE
               Contenido  = &LinReg
            ENDIF
            Linea(Actual)  = Contenido
            NumRg(Actual)  = RECNO()
            @ LinAct,Xo+2 SAY Linea(Actual)
            Ultimo = IIF( MaxLin > Ultimo, Ultimo+1, Ultimo)
            SetFin     = No
            Listar     = No
            Refresco   = No
            SetCursor  = No
            IF .NOT. INLIST(UltTecla,Enter,CtrlW,F10)
               Set_Append = No
            ENDIF
         ELSE
            IF Ultimo>0
               GOTO NumRg(1)
            ELSE
               UltTecla = escape_
               Fin      = Si
               Sigue    = No
            ENDIF
            SetFin     = No
            Listar     = Si
            Refresco   = Si
            SetCursor  = Si
            Set_Append = No
         ENDIF

      ELSE

         * Escribe l¡nea activa ------------------------------------------
         *
         LinAct = LinIni+Actual-1
         IF Ultimo <> 0
            @ LinAct,Xo+2 SAY Linea(Actual) COLOR SCHEME 15
            IF HAYSELLIN
               GOTO NumRg(Actual)
               DO &SelLin
            ENDIF
         ENDIF
         *
         * ---------------------------------------------------------------
         * Teclas de control ---------------------------------------------
         *
         UltTecla  = 0
         DO WHILE .NOT. (CHR(UltTecla)$CURSOR)
            UltTecla = INKEY(0)
            IF STR(UltTecla,3,0)$FKey
               EXIT
            ENDIF
            UltTecla      = IIF(UltTecla<0, 0, UltTecla)
         ENDDO
         SetCursor = (STR(UltTecla,3,0)$FKey .OR. CHR(UltTecla)$Ejecutar)
         SetFin    = No
         IF SetCursor
            ?? SYS(2002,1)
         ENDIF
         DO CASE
            CASE UltTecla = F1
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF1

            CASE UltTecla = F2
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF2

            CASE UltTecla = F3
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF3

            CASE UltTecla = F4
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF4

            CASE UltTecla = F5
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF5

            CASE UltTecla = F6
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF6

            CASE UltTecla = F7
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF7

            CASE UltTecla = F8
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF8

            CASE UltTecla = F9
               IF Ultimo >0
                  NumReg = NumRg(Actual)
                  GOTO NumReg
               ENDIF
               DO &MvPrgF9

            CASE UltTecla = escape_
               Fin       = Si
               Sigue     = No

            CASE (UltTecla = F10 .OR. UltTecla = CtrlW) .AND. ! Consulta
               @ LinAct,Xo+2 SAY Linea(Actual)
               NumReg = NumRg(Actual)
               GOTO NumReg
               Fin       = Si
               Sigue     = No
               IF HayPrgFin
                  DO &PrgFin
               ENDIF

            CASE UltTecla = PgUp .AND. Ultimo > 0
               GOTO NumRg(1)
               IF .NOT. dB_Top
                  j      = MaxLin
                  DO WHILE (j>=0) .AND. (&RegVal) .AND. (.NOT.BOF())
                     j  = j  - 1
                     SKIP -1
                  ENDDO
                  dB_Top = ! ((&RegVal) .AND. ! BOF())
                  IF ! BOF()
                     SKIP
                  ENDIF
                  Listar=Si
               ELSE
                  @ LinAct,Xo+2 SAY Linea(Actual)
                  Actual = 1
               ENDIF

            CASE UltTecla = PgDn .AND. Ultimo>0
               GOTO NumRg(Ultimo)
               SKIP
               IF (&RegVal) .AND. (.NOT. EOF())
                  dB_Top = No
                  Listar = Si
               ELSE
                  @ LinAct,Xo+2 SAY Linea(Actual)
                  Actual = Ultimo
               ENDIF

            CASE UltTecla = Abajo .AND. Ultimo > 0
               @ LinAct,Xo+2 SAY Linea(Actual)
               IF Actual=Ultimo
                  IF Actual=MaxLin
                     GOTO NumRg(Actual)
                     SKIP
                     dB_Bottom= ! ((&RegVal) .AND. (.NOT.EOF()))
                     IF ! db_Bottom
                        Contenido = []
                        IF HayEscLin
                           DO &EscLin WITH Contenido
                        ELSE
                           Contenido  = &LinReg
                        ENDIF
                        j =1
                        DO WHILE j <MaxLin
                           Linea(j)  = Linea(j+1)
                           NumRg(j)  = NumRg(j+1)
                           j =j +1
                        ENDDO
                        Linea(Actual)  = Contenido
                        NumRg(Actual)  = RECNO()
                        SCROLL Yo+1,Xo+1,Y1,X1-1,+1
                        Ultimo = IIF( MaxLin > Ultimo, Ultimo+1, Ultimo)
                        dB_Top = No
                     ELSE
                        Set_Append = Adiciona
                        MsgAdd    = Si
                     ENDIF
                  ELSE
                     Set_Append = Adiciona
                     MsgAdd    = Si
                  ENDIF
               ELSE
                  Actual=Actual+1
               ENDIF

            CASE UltTecla = Arriba .AND. Ultimo>0
                @ LinAct,Xo+2 SAY Linea(Actual)
               IF Actual > 1
                  Actual = Actual -1
               ELSE
                  IF ! db_Top
                     GOTO NumRg(1)
                     SKIP -1
                     dB_Top = ! (&RegVal .AND. ! BOF())
                  ENDIF
                  IF ! db_Top
                     j =MaxLin+1
                     DO WHILE j >2
                        j =j -1
                        Linea(j)  = Linea(j-1)
                        NumRg(j)  = NumRg(j-1)
                     ENDDO
                     Contenido = []
                     IF HayEscLin
                        DO &EscLin WITH Contenido
                     ELSE
                        Contenido  = &LinReg
                     ENDIF
                     Linea(1)  = Contenido
                     NumRg(1)  = RECNO()
                     SCROLL Yo+1,Xo+1,Y1,X1-1,-1
                     IF Ultimo=MaxLin
                        dB_Bottom=No
                     ENDIF
                     Ultimo = IIF( MaxLin > Ultimo, Ultimo+1, Ultimo)
                  ENDIF
               ENDIF

            CASE UltTecla = Home
               EXIT

            CASE UltTecla = End .AND. Ultimo > 0
               SetFin = Si

            CASE UltTecla = Enter  .AND. Consulta .AND. Ultimo > 0
               NumReg = NumRg(Actual)
               GOTO NumReg
               Sigue     = No
               EXIT

            CASE UltTecla = Enter  .AND.  Modifica .AND. ! Consulta
               IF Actual<=Ultimo
                  NumReg = NumRg(Actual)
                  GOTO NumReg
                  Crear  = No
                  @ LinAct,Xo+2 SAY Linea(Actual)
                  DO &EdiLin
                  IF UltTecla <> escape_
                     IF HAYGRBLIN
                        DO &GrbLin
                     ENDIF
                     Contenido = []
                     IF HayEscLin
                        DO &EscLin WITH Contenido
                     ELSE
                        Contenido  = &LinReg
                     ENDIF
                     Linea(Actual)  = Contenido
                     NumRg(Actual)  = RECNO()
                  ENDIF
               ELSE
                  Set_Append = Si
                  MsgAdd     = No
               ENDIF

            CASE UltTecla = Del   .AND. Ultimo>0 .AND. ! Consulta
               NumReg = NumRg(Actual)
               GOTO NumReg
               @ LinAct,Xo+2 SAY Linea(Actual) COLOR W*/N
               Msg1 = "Desea Anular el Item"
               Msg2 = "(S)i / (N)o"
               Rst=Aviso(20,Msg1,Msg2,[],3,'SN'+CHR(27),0,.T.,.F.,.T.)
               Set_Cursor = Si
               IF Rst = 'S'
                  DO &BrrLin
               ENDIF
               IF Actual > 1
                  GOTO NumRg(1)
               ELSE
                  IF db_Top
                     EXIT
                  ELSE
                     IF Ultimo = Actual
                        SetFin = Si
                     ELSE
                        GOTO NumRg(2)
                     ENDIF
                  ENDIF
               ENDIF
               Listar = Si
               Refresco = Si

            CASE UltTecla = Ins   .AND. Ultimo>0  .AND. ! Consulta
               @ LinAct,Xo+2 SAY Linea(Actual)
               SCROLL LinAct,Xo+1,Y1,X1-1,-1
               IF HAYEDILIN
                  NumReg = NumRg(Actual)
                  GOTO NumReg
                  Crear = .T.
                  DO &EdiLin
               ENDIF
               IF UltTecla <> escape_
                  Set_Append = Si
                  DO &InsLin
               ENDIF
               IF Actual > 1
                  GOTO NumRg(1)
               ENDIF
               Listar = Si
               Refresco = Si
               Set_Append = No

         ENDCASE
      ENDIF

      *
      * Desactivar Cursor
      * ------------------
      IF SetCursor
         ?? SYS(2002)
      ENDIF

      *
      * Ir al Ultimo Registro
      * ---------------------
      IF SetFin
         IF TRIM(VClave) == []
            GOTO BOTTOM
            Listar = Si
         ELSE
            SEEK VClave+CHR(255)
            RegPxm = RECNO(0)
            IF .NOT. FOUND()
               IF RegPxm = 0
                  GOTO BOTTOM
               ELSE
                  GOTO RegPxm
                  IF ! &RegVal
                     SKIP -1
                  ENDIF
               ENDIF
            ENDIF
            Listar = &RegVal
         ENDIF
         IF Listar
            db_Top = No
         ENDIF
         Refresco = No
         SetFin   = No
      ENDIF

   ENDDO .NOT. Fin

ENDDO .NOT. Sigue
*
* ------------------------------------------------------------------------
IF Static
   RESTORE SCREEN FROM dBTemp             && Reponemos la pantalla.
ENDIF
?? SYS(2002,1)
RELEASE db_Pinta
RETURN
******************
procedure admguser
******************
*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º 01/03/93            ADMGUSER.SPR               19:15:18 º
*       º                                                         º
*       ÇÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¶
*       º                                                         º
*       º Author's Name   Jorge Mieses Valencia                   º
*       º                                                         º
*       º Copyright (c) 1993 Company Name VALMIESA                º
*       º Address                                                 º
*       º City,     Zip                                           º
*       º                                                         º
*       º Description:                                            º
*       º This program was automatically generated by GENSCRN.    º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½


*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                    Window definitions                   º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*

IF NOT WEXIST("admmuser")
   DEFINE WINDOW admmuser ;
      FROM INT((SROW()-10)/2),INT((SCOL()-31)/2) ;
      TO INT((SROW()-10)/2)+9,INT((SCOL()-31)/2)+30 ;
      TITLE "USUARIOS" ;
      NOFLOAT ;
      NOCLOSE ;
      SHADOW ;
      SYSTEM ;
      COLOR SCHEME 1
ENDIF


*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º             ADMGUSER Setup Code - SECTION 2             º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*

#REGION 1
ACTIVATE SCREEN
CLEAR
FOR i = 0 TO SROW()-1
   @ i,0 SAY REPLICATE("°",SCOL()) COLOR SCHEME 11
ENDFOR
SET SYSMENU OFF
USE admruser IN 2 ORDER RUSE01
USE admmuser IN 1 ORDER MUSE01
DIMENSION atipo[len(admruser.Tipo)]
STORE .F. TO  m.admnin,aTipo
m.Graba = 0
SEEK GsUsuario
IF ! FOUND()
   CLOSE DATA
   RETURN
ENDIF
SELE ADMMUSER
m.login    = login
m.password = Descript(Password,recno())

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                 ADMGUSER Screen Layout                  º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*

#REGION 1
IF WVISIBLE("admmuser")
   ACTIVATE WINDOW admmuser SAME
ELSE
   ACTIVATE WINDOW admmuser NOSHOW
ENDIF
@ 0,2 TO 2,26 DOUBLE
@ 5,2 TO 7,26 DOUBLE
@ 1,4 SAY "Usuario :"
@ 1,14 GET m.login PICTURE "@!"  VALID _qdr159s4s() WHEN Master
@ 3,4 SAY "Clave   :"
@ 3,14 GET m.password PICTURE "@K!" COLOR ,X
@ 4,7 GET m.admnin PICTURE "@*C \<Administrador"  DEFAULT 0 ;
   VALID _qdr159teg()
@ 6,4 GET m.graba PICTURE "@*HN \<Grabar;\<Anular" DEFAULT 1 VALID _qdr159u0g()

IF NOT WVISIBLE("admmuser")
   ACTIVATE WINDOW admmuser
ENDIF

READ CYCLE

RELEASE WINDOW admmuser

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º                  ADMGUSER Cleanup Code                  º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*

#REGION 1
RELEASE atipo

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º _QDR159S4S           m.login VALID                      º
*       º                                                         º
*       º Function Origin:                                        º
*       º                                                         º
*       º From Screen:         ADMGUSER,     Record Number:    2  º
*       º Variable:            m.login                            º
*       º Called By:           VALID Clause                       º
*       º Object Type:         Field                              º
*       º Snippet Number:      1                                  º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
FUNCTION _qdr159s4s     &&  m.login VALID
#REGION 1
SELECT admruser
SEEK m.login
DO CASE
   CASE LASTKEY() = PGUP
      IF EOF()
         GOTO BOTTOM
      ELSE
         IF ! BOF()
            SKIP -1
         ENDIF
      ENDIF
      DO WHILE ! BOF()
         IF  Modulo = GsModulo
            EXIT
         ENDIF
         SKIP -1
      ENDDO
      IF  Modulo = GsModulo
         m.login = login
         ?? CHR(7)
      ENDIF
   CASE LASTKEY() = PGDN
      IF EOF()
         GOTO BOTTOM
      ELSE
         SKIP
      ENDIF
      DO WHILE ! EOF()
         IF  Modulo = GsModulo
            EXIT
         ENDIF
         SKIP
      ENDDO
      IF  Modulo = GsModulo
         m.login = login
         ?? CHR(7)
      ENDIF
ENDCASE
IF TRIM(M.LOGIN) == ""
   RETURN .F.
ENDIF
SELECT admmuser
SEEK m.login
IF FOUND()
   m.password = DESCRIPT(admmuser.password,RECNO())
ELSE
   m.password = SPACE(LEN(admmuser.password))
ENDIF
SELECT admruser
SEEK m.login+GsModulo
STORE .F. TO ;
   m.admnin,;
   atipo
IF FOUND()
   m.admnin  = admruser.categoria
   FOR i = 1 to LEN(admruser.Tipo)
      atipo[i] = SUBS(admruser.Tipo,i,1) = "X"
   NEXT
ENDIF
SHOW GETS
RETURN .T.

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º _QDR159TEG           m.admnin VALID                     º
*       º                                                         º
*       º Function Origin:                                        º
*       º                                                         º
*       º From Screen:         ADMGUSER,     Record Number:    4  º
*       º Variable:            m.admnin                           º
*       º Called By:           VALID Clause                       º
*       º Object Type:         Check Box                          º
*       º Snippet Number:      2                                  º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
FUNCTION _qdr159teg     &&  m.admnin VALID
#REGION 1
IF m.admnin
   STORE .T. TO ;
   m.maestro,;
   aTipo
   SHOW GETS
ENDIF
RETURN .T.

*       ÖÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ·
*       º                                                         º
*       º _QDR159U0G           m.graba VALID                      º
*       º                                                         º
*       º Function Origin:                                        º
*       º                                                         º
*       º From Screen:         ADMGUSER,     Record Number:    5  º
*       º Variable:            m.graba                            º
*       º Called By:           VALID Clause                       º
*       º Object Type:         Push Button                        º
*       º Snippet Number:      3                                  º
*       º                                                         º
*       ÓÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ½
*
FUNCTION _qdr159u0g     &&  m.graba VALID
#REGION 1
IF ! UPDATE()
   RETURN .T.
ENDIF
SELECT admruser
SEEK m.login+GsModulo
IF m.Graba = 1
   IF ! FOUND()
      APPEND BLANK
      IF RLOCK()
         REPLACE admruser.Login WITH m.Login
         REPLACE admruser.Modulo WITH GsModulo
      ENDIF
   ENDIF
   m.Tipo = ""
   FOR i = 1 to LEN(admruser.Tipo)
      m.Tipo = m.Tipo + IIF(atipo[i],"X"," ")
   NEXT
   IF RLOCK()
      REPLACE admruser.Categoria WITH m.admnin
      REPLACE admruser.Tipo WITH m.Tipo
   ENDIF
ELSE
   IF FOUND()
      IF RLOCK()
         DELETE
      ENDIF
   ENDIF
ENDIF
SELECT admmuser
SEEK m.login
IF m.graba = 1
   IF ! FOUND()
      APPEND BLANK
   ENDIF
   IF RLOCK()
      REPLACE admmuser.Login WITH m.Login
      REPLACE admmuser.password WITH ;
       encripta(m.password,RECNO())
   ENDIF
ELSE
   IF ! SEEK(m.Login,"admruser")
      IF RLOCK()
         DELETE
      ENDIF
   ENDIF
ENDIF
STORE .F. TO ;
   m.admnin,;
   aTipo
m.Graba = 0
m.login = SPACE(LEN(admmuser.login))
m.password = SPACE(LEN(admmuser.password))
_Curobj = 1
SHOW GETS
RETURN .T.
***************************
procedure edita
****************
PARAMETERS ProgKey,ProgMst,ProgEdt,ProgElm,ProgRep,NClave,ZClave,Opciones,ProgLoc

PRIVATE    dbEdita,NumOpc,Tecla,Opc,RegVal,Sigue,Busca,Aviso,Seleccion
PRIVATE    Muestra,Editar,Caso,Nx,Condicion,Loc,Yo,Xo,Lo,Camp,Fmt
PRIVATE    PideKey,ChkMsg,ChrVal,Nx,LargOps,OpsVal,MaxOpcs

RELEASE    dbOpcs
RELEASE    dbPosc
DIMENSION  dbOpcs(6),dbPosc(6)

IF _Dos OR _Unix
	ACTIVATE SCREEN
ENDIF

Nx       = 1
MaxOpcs  = 0
OpsVal   = []
LargOps  = 0

*
**************************************************************************
* Opciones V lidas
*

DO WHILE Nx <= LEN(Opciones)
   ChrVal = SUBSTR(UPPER(Opciones),Nx,1)
   IF ChrVal$'ICMALR'
      MaxOpcs = MaxOpcs + 1
      OpsVal  = OpsVal+ ChrVal
      DO CASE
         CASE ChrVal = 'I'
            dbOpcs(MaxOpcs) = 'Ingresos'
            LargOps  = LargOps  + 8
         CASE ChrVal = 'C'
            dbOpcs(MaxOpcs) = 'Crear'
            LargOps  = LargOps  + 5
         CASE ChrVal = 'M'
            dbOpcs(MaxOpcs) = 'Modificar'
            LargOps  = LargOps  + 9
         CASE ChrVal = 'A'
            dbOpcs(MaxOpcs) = 'Anular'
            LargOps  = LargOps  + 6
         CASE ChrVal = 'L'
            dbOpcs(MaxOpcs) = 'Localizar'
            LargOps  = LargOps  + 9
         CASE ChrVal = 'R'
            dbOpcs(MaxOpcs) = 'Reportes'
            LargOps  = LargOps  + 8
      ENDCASE
   ENDIF
   Nx = Nx + 1
ENDDO
IF MaxOpcs = 0
   RETURN
ENDIF

Rx = INT((80 - LargOps)/(MaxOpcs+1))
Nx = INT(MOD((80 - LargOps),(MaxOpcs+1)))/2

Ops = 1
DO WHILE Ops <= MaxOpcs
   dbPosc(Ops) = Nx+Rx
   Nx  = Nx + Rx + LEN(dbOpcs(Ops))
   Ops = Ops +1
ENDDO


SAVE SCREEN TO dbEdita

Opc       = 1
Seleccion = .T.
ZClave    = TRIM(ZClave)
IF NClave==[]
   RegVal    = ".NOT. EOF()"
   IF ! EOF()
      GOTO TOP
   ENDIF
ELSE
   RegVal    = "&NClave = ZClave"
   IF ! &NClave = ZClave
      SEEK ZClave
   ENDIF
ENDIF

*
**************************************************************************
* Rutina Principal
*

DO WHILE .T.
   IF Seleccion
      @ 23,0
      Tecla = 0
      Muestra = .T.
      Nx = 1
      DO WHILE Nx <= MaxOpcs
         @ 23,dbPosc(Nx) SAY dbOpcs(Nx)
         Nx = Nx +1
      ENDDO
      DO WHILE .T.
         IF Muestra
            IF &RegVal
               DO &ProgMst      && Pinta la pantalla con el registro actual
            ELSE
               RESTORE SCREEN FROM dbEdita
               Nx = 1
               DO WHILE Nx <= MaxOpcs
                  @ 23,dbPosc(Nx) SAY dbOpcs(Nx)
                  Nx = Nx +1
               ENDDO
            ENDIF
            Muestra = .F.
         ENDIF
         @ 23,dbPosc(Opc) SAY dbOpcs(Opc) COLOR SCHEME 7
         Tecla = INKEY(0)
         ChrVal = UPPER(CHR(IIF(Tecla>0 .AND. Tecla<255,Tecla,32)))
         DO CASE
            CASE Tecla = 27
               CLOSE DATA
               RETURN
            CASE Tecla = 19
               @ 23,dbPosc(Opc) SAY dbOpcs(Opc)
               Opc   = IIF(Opc > 1, Opc-1, MaxOpcs)
            CASE Tecla = 4
               @ 23,dbPosc(Opc) SAY dbOpcs(Opc)
               Opc   = IIF(Opc < MaxOpcs, Opc+1, 1)
            CASE ChrVal$OpsVal
               @ 23,dbPosc(Opc) SAY dbOpcs(Opc)
               Opc   = AT(ChrVal,OpsVal)
            CASE Tecla = 18
               IF &RegVal .AND. ! BOF()
                  SKIP -1
                  IF .NOT. &RegVal
                     SKIP
                  ENDIF
               ELSE
                  SEEK ZClave
               ENDIF
               Muestra = .T.
            CASE Tecla = 3
               IF &RegVal
                  SKIP
                  IF .NOT. &RegVal .OR. EOF()
                     SKIP -1
                  ENDIF
               ELSE
                  SEEK ZClave
               ENDIF
               Muestra = .T.
            CASE Tecla = 31            && ^ PgUp
               IF ZCLAVE == ""
                  GOTO TOP
               ELSE
                  SEEK ZClave
               ENDIF
               Muestra = .T.
            CASE Tecla = 30            && ^ PgDn
               IF ZCLAVE = ""
                  GOTO BOTTOM
               ELSE
                  SEEK ZClave + CHR(255)
               ENDIF
               Muestra = .T.
            CASE Tecla = 1
               SEEK ZClave
            CASE Tecla = 6
               EXIT
            CASE Tecla = 13
               EXIT
         ENDCASE
         UltTecla = Tecla
      ENDDO
   ELSE
      IF &RegVal
         DO &ProgMst       && Pinta la pantalla con el registro actual
      ENDIF
   ENDIF

   @ 23,0 CLEAR
   @ 23,3 SAY dbOpcs(Opc) COLOR SCHEME 7

   ChrVal = SUBSTR(dbOpcs(Opc),1,1)
   Crear  = .F.

   DO CASE
      CASE  ChrVal='C'           && ******* Crear
         GOTO BOTTOM
         IF .NOT. EOF()
            SKIP
         ENDIF
         ChkMsg    = .T.
         PideKey   = .T.
         Seleccion = .T.
         Editar    = .T.
         Crear     = .T.
      CASE  ChrVal$'I'            && ******* Ingresos
         IF &RegVal .AND. Tecla = 13
            Seleccion = .T.
            Editar    = .T.
            PideKey   = .F.
         ELSE
            Editar    = .T.
            Seleccion = .F.
            ChkMsg    = .F.
            PideKey   = .T.
            Crear     = .T.
         ENDIF
      CASE  ChrVal$'M'            && ******* Modificar
         IF &RegVal .AND. Tecla = 13
            Seleccion = .T.
            Editar    = .T.
            PideKey   = .F.
         ELSE
            Editar    = .T.
            Seleccion = .F.
            ChkMsg    = .T.
            PideKey   = .T.
         ENDIF
      CASE  ChrVal='A'             && ******* Anular
         IF &RegVal .AND. Tecla = 13
            Seleccion = .T.
            Editar    = .F.
            ChkMsg    = .T.
            PideKey   = .F.
         ELSE
            Seleccion = .F.
            Editar    = .F.
            ChkMsg    = .T.
            PideKey   = .T.
         ENDIF
      CASE  ChrVal='L'             && ******* Localizar
         PideKey   = .F.
         Editar    = .F.
         Seleccion = .T.
         DO &Progloc
      CASE  ChrVal='R'             && ******* Reporte
         DO &ProgRep
         PideKey   = .F.
         Editar    = .F.
         Seleccion = .T.
   ENDCASE
*************
   IF PideKey
      RESTORE SCREEN FROM dbEdita
      @ 23,0 CLEAR
      @ 23,3 SAY dbOpcs(Opc) COLOR SCHEME 7
      dbSigue = .T.
      DO WHILE dbSigue
         UltTecla = 0
         DO &ProgKey
         UltTecla = LASTKEY()
         IF UltTecla = 27
            Editar    = .F.
            Seleccion = .T.
            EXIT
         ENDIF
         dbSigue  = .F.
         IF ChkMsg
            IF ChrVal='C'
               ok = .NOT. &RegVal
            ELSE
               ok = &RegVal
            ENDIF
            IF ok
               IF FOUND()
                  DO &ProgMst
                  IF ChrVal='A'
                     IF Aviso(20,"Desea Anular el Registro","(S)i / (N)o",;
                        [],3,'SN'+CHR(27),0,.T.,.T.,.T.)='S'
                        DO &ProgElm
                     ENDIF
                  ENDIF
               ENDIF
               EXIT
            ENDIF
            IF &RegVal
               Aviso  = Aviso(20," Registro Existente ",[],[],;
                         3,[],3,.T.,.T.,.T.)
            ELSE
               Aviso  = Aviso(21," Registro No Existente ",[],[],;
                         3,[],3,.T.,.T.,.T.)
            ENDIF
            dbSigue = .T.
         ENDIF
      ENDDO

   ENDIF
************
   IF ChrVal='A' .AND. .NOT. PideKey
      IF Aviso(20,"Desea Anular el Registro","(S)i / (N)o",;
         [],3,'SN'+CHR(27),0,.T.,.T.,.T.)='S'
         DO &ProgElm
      ENDIF
      Seleccion  = .T.
   ENDIF
************
   IF Editar
      UltTecla = 0
      DO &ProgEdt
      UltTecla = LASTKEY()
      DO CASE
         CASE UltTecla = 18
            SKIP -1
            IF .NOT. &RegVal .OR. BOF()
               SKIP
            ENDIF
            Tecla = 13
            Seleccion = .F.
         CASE UltTecla = 3
            SKIP
            IF .NOT. &RegVal .OR. EOF()
               SKIP -1
            ENDIF
            Tecla = 13
            Seleccion = .F.
         CASE UltTecla = 27
            Seleccion = .T.
         OTHERWISE
            Tecla = 6
            Seleccion = .F.
      ENDCASE
   ENDIF
ENDDO
IF _unix OR _Dos
	CLOSE DATA
ENDIF
RETURN
*!*********************************************************************
*!
*!      Funcion:   DIA
*!
*!
*!
*!*********************************************************************
FUNC DIA
PARAMETER Parametro1, Parametro2
PRIVATE NumDia , DiaTexto , StrTipo

IF TYPE('Parametro1')='D'
   NumDia = DOW(Parametro1)
ELSE
   NumDia = Parametro1
ENDIF
DO CASE
   CASE NumDia = 1
      DiaTexto = ("domingo")
   CASE NumDia = 2
      DiaTexto = ("lunes")
   CASE NumDia = 3
      DiaTexto = ("martes")
   CASE NumDia = 4
      DiaTexto = ("miercoles")
   CASE NumDia = 5
      DiaTexto = ("jueves")
   CASE NumDia = 6
      DiaTexto = ("viernes")
   CASE NumDia = 7
      DiaTexto = ("sabado")
   OTHER
      RETURN(" ")
ENDCASE
DO CASE
   CASE  TYPE("Parametro2") <> "N"
   CASE  Parametro2= 1
      DiaTexto = UPPER(DiaTexto)
   CASE  Parametro2= 3
      DiaTexto = PROPER(DiaTexto)
ENDCASE
RETURN DiaTexto
*!*********************************************************************
*!
*!      Procedure: Numero
*!                Num        : El n£mero que se desea escribir.
*!                Dec        : N£mero de Decimales.
*!                StrTipo    : Forma de escribir el n£mero :
*!                             1 Mayusculas
*!                             2 Minusculas
*!                             3 Propia
*!
*!*********************************************************************
FUNC NUMERO
PARAMETERS Num , Dec , StrTipo

PRIVATE NumTexto,CienTexto,Ciento,Miles,Largo,Entero,Decimal

NumTexto = []
CienTexto= []
Entero   = LTRIM(STR(INT(Num),15,0))
Decimal  = RIGHT(STR(NUM,15,Dec),Dec)
Largo    = LEN(Entero)
Ciento   = []
Miles    = 0

DO WHILE Largo > 0

   Ciento    = RIGHT('   '+Entero,3)     && Toma los Tres £ltimos digitos
   Digito1   = SUBSTR(Ciento,3,1)        && El Ultimo D¡gito
   Digito2   = SUBSTR(Ciento,2,1)        && Pen£ltimo D¡gito
   Digito3   = SUBSTR(Ciento,1,1)        && Antepen£ltimo D¡gito
   CienTexto = []
   * Texto del £ltimo d¡gito *(UNIDADES)**********************************
   DO CASE
      CASE Digito1='1'
         CienTexto='uno'
      CASE Digito1='2'
         CienTexto='dos'
      CASE Digito1='3'
         CienTexto='tres'
      CASE Digito1='4'
         CienTexto='cuatro'
      CASE Digito1='5'
         CienTexto='cinco'
      CASE Digito1='6'
         CienTexto='seis'
      CASE Digito1='7'
         CienTexto='siete'
      CASE Digito1='8'
         CienTexto='ocho'
      CASE Digito1='9'
         CienTexto='nueve'
   ENDCASE
   * Texto de los dos £ltimos d¡gitos **(DECENAS)*************************
   DO CASE
      CASE Digito2='1'
         DO CASE
            CASE Digito1='0'
               CienTexto='diez'
            CASE Digito1='1'
               CienTexto='once'
            CASE Digito1='2'
               CienTexto='doce'
            CASE Digito1='3'
               CienTexto='trece'
            CASE Digito1='4'
               CienTexto='catorce'
            CASE Digito1='5'
               CienTexto='quince'
            OTHERWISE
               CienTexto='dieci'+CienTexto
         ENDCASE
      CASE Digito2='2'
         CienTexto= IIF(Digito1#'0','veinti'   +CienTexto,'veinte')
      CASE Digito2='3'
         CienTexto= IIF(Digito1#'0','treinti'  +CienTexto,'treinta')
      CASE Digito2='4'
         CienTexto= IIF(Digito1#'0','cuarenti' +CienTexto,'cuarenta')
      CASE Digito2='5'
         CienTexto= IIF(Digito1#'0','cincuenti'+CienTexto,'cincuenta')
      CASE Digito2='6'
         CienTexto= IIF(Digito1#'0','sesenti'  +CienTexto,'sesenta')
      CASE Digito2='7'
         CienTexto= IIF(Digito1#'0','setenti'  +CienTexto,'setenta')
      CASE Digito2='8'
         CienTexto= IIF(Digito1#'0','ochenti'  +CienTexto,'ochenta')
      CASE Digito2='9'
         CienTexto= IIF(Digito1#'0','noventi'  +CienTexto,'noventa')
   ENDCASE
   * Texto de los tres £ltimos d¡gitos *(CENTENAS)************************
   DO CASE
      CASE Digito3='1'
         CienTexto= IIF(CienTexto==[],'cien','ciento '+CienTexto)
      CASE Digito3='2'
         CienTexto='doscientos '   +CienTexto
      CASE Digito3='3'
         CienTexto='trescientos '  +CienTexto
      CASE Digito3='4'
         CienTexto='cuatrocientos '+CienTexto
      CASE Digito3='5'
         CienTexto='quinientos '   +CienTexto
      CASE Digito3='6'
         CienTexto='seiscientos '  +CienTexto
      CASE Digito3='7'
         CienTexto='setecientos '  +CienTexto
      CASE Digito3='8'
         CienTexto='ochocientos '  +CienTexto
      CASE Digito3='9'
         CienTexto='novecientos '  +CienTexto
   ENDCASE
   ***********************************************************************

   IF Miles > 0 .AND. RIGHT(CienTexto,3)='uno'
      CienTexto = SUBSTR(CienTexto,1,LEN(CienTexto)-1)
   ENDIF

   DO CASE
      CASE Miles = 0
         NumTexto= CienTexto
      CASE (Miles= 1 .OR. Miles=3 .OR. Miles=5) .AND. VAL(Ciento)>0
         NumTexto= CienTexto + ' mil ' + LTRIM(NumTexto)
      CASE Miles = 2
         IF CienTexto = 'un'
            NumTexto  = 'un millon '+LTRIM(NumTexto)
         ELSE
            NumTexto  = CienTexto+' millones '+LTRIM(NumTexto)
         ENDIF
      CASE Miles =4
         IF NumTexto = 'millones'
            NumTexto = []
         ENDIF
         IF CienTexto= 'un'
            NumTexto = 'un billon '+LTRIM(NumTexto)
         ELSE
            NumTexto = CienTexto + ' billones '+LTRIM(NumTexto)
         ENDIF
   ENDCASE
   Miles   = Miles +1
   Entero  = SUBSTR(Entero , 1 ,IIF(Largo>3 ,Largo-3,0) )
   Largo   = Len(Entero)
ENDDO

NumTexto = LTRIM(TRIM(NumTexto))
IF NumTexto == []
   NumTexto = 'cero'
ENDIF

IF Dec > 0
   NumTexto = NumTexto + ' con '+Decimal+'/100'
ENDIF
DO CASE
   CASE  TYPE("StrTipo") <> "N"
   CASE  StrTipo = 1
      NumTexto = UPPER(NumTexto)
   CASE  StrTipo = 3
      NumTexto = UPPER(SUBSTR(NumTexto,1,1))+SUBSTR(NumTexto,2,LEN(NumTexto)-1)
   CASE  StrTipo = 4
      Numtexto = PROPER(NumTexto)
ENDCASE

RETURN NumTexto
*!*********************************************************************
*!
*!      Procedure: Descriptar
*!                Parametro1    Variable a Descriptar
*!                Parametro2    Variable Numerica de encriptado
*!
*!*********************************************************************
function descript
******************
PARAMETER Parametro1, Parametro2
PRIVATE Len,Retorno,XChar,X,Rotado,Dato,Enc1
set talk off
set echo off
Dato = Parametro1
Enc1 = Parametro2
Len=Len(Dato)
Retorno=[]
X=1
DO WHILE Len>0
   Xchar=ASC(SUBSTR(Dato,Len,1))
   IF Xchar>127
      Xchar=Xchar-127
   ELSE
      Xchar=Xchar+127
   ENDIF
   Xchar=Xchar+32-X
   IF Xchar<0
      Xchar=0
   ENDIF
   Retorno=Retorno+CHR(Xchar)
   Len=Len-1
   X=X+1
ENDDO
Rotado=[]
Len=LEN(Dato)
X=Len-MOD(Enc1,Len)+1
DO WHILE LEN(Rotado)<Len
   IF X>Len
      X=1
   ENDIF
   Xchar=Substr(Retorno,X,1)
   Rotado=Rotado+Xchar
   X=X+1
ENDDO
RETURN Rotado
*!*********************************************************************
*!
*!      Procedure: Encriptar
*!                Parametro1    Variable a Encriptar
*!                Parametro2    Variable Numerica de encriptado
*!
*!*********************************************************************
function Encripta
*****************
PARAMETER Parametro1, Parametro2
PRIVATE Len,Retorno,XChar,X,Rotado,Dato,Enc1
set talk off
set echo off
Dato = Parametro1
Enc1 = Parametro2
Len=LEN(Dato)
Retorno=[]
Rotado =[]
X=MOD(Enc1,Len)+1
DO WHILE LEN(Rotado)<Len
   IF X>Len
      X=1
   ENDIF
   Xchar=SUBSTR(Dato,X,1)
   Rotado=Rotado+Xchar
   X=X+1
ENDDO
DO WHILE Len>0
   Xchar=ASC(SUBSTR(Rotado,Len,1))
   Xchar=Xchar-32+Len
   IF Xchar<0
      Xchar=0
   ENDIF
   IF Xchar>127
      Xchar=Xchar-127
   ELSE
      Xchar=Xchar+127
   ENDIF
   Retorno=Retorno+Chr(Xchar)
   Len=Len-1
ENDDO
RETURN Retorno
***************
function indexa
***************
PARAMETERS DBFS,TAGS
PRIVATE NumOpc
IF ! ( FILE(DBFS+".dbf") AND FILE(TAGS+".dbf") )
   WAIT "No Existe Formatos de Indexaci¢n" WINDOW NOWAIT
   RETURN
ENDIF
USE (DBFS) IN 1 ALIAS DBFS EXCLUSIVE
USE (TAGS) IN 2 ALIAS TAGS EXCLUSIVE

IF ! (USED("DBFS") .AND. USED("TAGS"))
   CLOSE DATA
   WAIT "Error en Apertura de Archivos" WINDOW NOWAIT
   RETURN
ENDIF
SELECT TAGS
INDEX ON ARCHIVO TAG ARCHIVO
SET ORDER TO ARCHIVO
REPLACE ALL TAGS.MARCA WITH "X"
SELECT DBFS
SET RELATION TO ARCHIVO INTO TAGS
REPLACE ALL DBFS.MARCA WITH " "
REPLACE ALL DBFS.EMPAQUETA WITH IIF(DBFS.PacArchivo,"X"," ")

* Pintando la Pantalla

IF _UNIX OR _DOS
	ACTIVATE SCREEN
ELSE

ENDIF	
CLEAR
@ 0,0 TO 23,79 PANEL
@ 0,26 SAY " MANTENIMIENTO DE ARCHIVOS  "
@  6,4  SAY "                                                                         "
@  7,4  SAY "                                                                         "
@  8,4  SAY "                            Este proceso tiene por finalidad de  indexar "
@  9,4  SAY "                        parcial o totalmente las bases de datos que  usa "
@ 10,4  SAY "                        este sistema.                                    "
@ 11,4  SAY "                                                                         "
@ 12,4  SAY "                            Este proceso realiza una apertura de archivo "
@ 13,4  SAY "                        exclusiva por tanto deber  ser  la  £nica  tarea "
@ 14,4  SAY "                        que se efectue sobre el sistema.                 "
@ 15,4  SAY "                   "
@ 15,5  SAY "                 "
@ 16,4  SAY "                                                                         "

@ 17,31 TO 21,69
@ 18,35 SAY "Eliga su Opci¢n para Continuar"
@ 20,36 GET NumOpc DEFAULT 1 PICT "@*HT \<Total;\<Parcial;\<Cancelar"
READ CYCLE
IF LASTKEY()=27 .OR. NumOpc = 3
   CLOSE DATA
   RETURN
ENDIF
SELECT DBFS
SET RELATION TO
IF NumOpc = 2
   GsMsgKey = " [Esc] Cancela  [F10] Ejecuta  [X] Marca   [Space] Desmarca "
   DO LIB_MTEC WITH 99
   DEFINE WINDOWS Win2 FLOAT FROM 8,29 TO 22,79 COLOR SCHEME 10
   SELECT DBFS
   GOTO TOP
   BROWSE TITLE "BASE DE DATOS" FIELD ;
    DBFS.MARCA:1:P="!",;
    DBFS.EMPAQUETA:1:W=DBFS.PACARCHIVO:P="!",;
    DBFS.ARCHIVO:R:W=.F.,;
    DBFS.CONCEPTO:R:W=.F. WINDOW Win2
   IF LASTKEY()=27
      RELEASE WINDOWS Win2
      CLOSE DATA
      RETURN
   ENDIF
   SELECT DBFS
   SET FILTER TO DBFS.MARCA = "X"
   SELECT TAGS
   SET FILTER TO TAGS.MARCA = "X"
   SELECT DBFS
ENDIF


DEFINE WINDOW Win2 FROM 18,2 TO 21,77 COLOR SCHEME 7
ACTIVATE WINDOW Win2

SELECT DBFS
SCAN
   NomArc = DBFS.Archivo
   USE (DBFS.Archivo) IN 3 ALIAS DAT EXCLUSIVE
   m.Empaqueta = .F.
   IF USED("DAT")
      SELECT DAT
      CLEAR
      @ 0,4 SAY "Base de Datos : "+DBF()
      NumReg = RECCOUNT()
      IF DBFS.PacArchivo AND ((NumOpc=2 AND DBFS.Empaqueta = "X") OR NumOpc=1)
         @ 1,0 SAY PADC("*** E M P A Q U E T A N D O ***",78)
         SET TALK ON
         SET TALK WINDOW
         PACK
         m.Empaqueta = .T.
         SET TALK OFF
      ENDIF
      CLEAR
      @ 0,4 SAY "Base de Datos : " + DBF()
      SELECT TAGS
      SEEK DBFS.Archivo
      SCAN REST WHILE DBFS.Archivo = TAGS.Archivo
         @ 1,04 SAY "Reconstruyendo: " + TAGS.Indice
         Campos = TAGS.Llave
         TagIdx = TAGS.Indice
         SELECT DAT
         SET TALK ON
         SET TALK WINDOW
         INDEX ON &Campos  TAG  &TagIdx  COMPACT
         SET INDEX TO (DBFS.Archivo+".CDX")
         SET TALK OFF
         SELECT TAGS
      ENDSCAN
   ENDIF
   SELECT DBFS
ENDSCAN
WAIT "Mantenimiento Completado" NOWAIT WINDOW
RELEASE WINDOWS Win2
CLOSE DATA
RETURN
*!*********************************************************************
*!
*!      Funcion:   MES
*!
*!
*!
*!*********************************************************************
FUNC MES
PARAMETER Parametro1, Parametro2
PRIVATE NumMes , MesTexto , StrTipo

IF TYPE('Parametro1')='D'
   NumMes = MONTH(Parametro1)
ELSE
   NumMes = Parametro1
ENDIF

DO CASE
   CASE NumMes = 0
      MesTexto = ("apertura")
   CASE NumMes = 1
      MesTexto = ("enero")
   CASE NumMes = 2
      MesTexto = ("febrero")
   CASE NumMes = 3
      MesTexto = ("marzo")
   CASE NumMes = 4
      MesTexto = ("abril")
   CASE NumMes = 5
      MesTexto = ("mayo")
   CASE NumMes = 6
      MesTexto = ("junio")
   CASE NumMes = 7
      MesTexto = ("julio")
   CASE NumMes = 8
      MesTexto = ("agosto")
   CASE NumMes = 9
      MesTexto = ("setiembre")
   CASE NumMes = 10
      MesTexto = ("octubre")
   CASE NumMes = 11
      MesTexto = ("noviembre")
   CASE NumMes = 12
      MesTexto = ("diciembre")
   CASE NumMes = 13
      MesTexto = ("cierre")
   OTHER
      RETURN(" ")
ENDCASE
DO CASE
   CASE  TYPE("Parametro2") <> "N"
   CASE  Parametro2= 1
      MesTexto = UPPER(MesTexto)
   CASE  Parametro2= 3
      MesTexto = PROPER(MesTexto)
ENDCASE
RETURN MesTexto
**************
function error
**************
PARAMETERS ErrNum,Mensaje,CurrPrg,CurrErr
PRIVATE TitError,TitSoluc1,TitSoluc2,TitProgr,Titcoment
PRIVATE Syscnf100,Syscnf101,Syscnf102,Syscnf103
PRIVATE Yo,Xo,XError,LenMax
SET TALK OFF
Syscnf100 =SYS(100)                        &&  setting SET CONSOLE (ON/OFF)
Syscnf101 =SYS(101)                        &&  device setting (SCREEN/PRINT)
Syscnf102 =SYS(102)                        &&  setting SET PRINT   (ON/OFF)
TitError = Mensaje                         && Titulo del Error
TitSoluc1= "Error de Estrutura"            && Posible Soluci¢n al Error
TitSoluc2= "Consultar con el area de sistemas"
TitProgr = "Procedimiento : "+CurrPrg      && Programa que Origino Error
TitComent= " [Enter]-Reintentar    [Esc]-Cancelar "
DO CASE
   CASE ErrNum=1705
      TitError = "Acesso denegado"
      TitSoluc1= "Atributo del Lectura y Escritura del Archivo"
      TitSoluc2= "Inhabilitado para el Usuario"
   CASE ErrNum=108 .AND. "USE"$UPPER(CurrErr)
      *** Error: File in use by another ***
      TitError = "Archivo en uso por Otro Ususario"
      TitSoluc1= "Requiere ¢ Existe"
      TitSoluc2= "una apertura en forma Exclusiva"
   CASE ErrNum=108
      *** Error: File in use by another ***
      ** FLOCK() por otro usuario
      TitError = "Archivo en uso por Otro Ususario"
      TitSoluc1= "Otro Usuario de Sistema"
      TitSoluc2= "Tiene bloqueado el Archivo"
   CASE ErrNum=109 .OR. ErrNum=130
      *** Error: Record in use by another.
      ** RLOCK() por otro usuario
      TitError = "Registro en uso por Otro Ususario"
      TitSoluc1= "Otro Usuario de Sistema"
      TitSoluc2= "Tiene bloqueado el Registro"
   CASE ErrNum=130
      *** Error: Record in not locket.
      TitError = "Registro no esta bloqueado"
      TitSoluc1= ""
      TitSoluc2= ""
   CASE ErrNum=111
      TitError = "Error en Grabaci¢n"
      TitSoluc1= "Archivo con Atributo de solo Lectura"
      TitSoluc2= "Verificar los Atributos de Usuario"
   CASE ErrNum=124
      TitError = "Invalida Redireci¢n de Impresora"
      TitSoluc1= "Impresora seleccionada no est "
      TitSoluc2= "registrada en el sistema."
   CASE ErrNum=125
      *** Error: Printer no Ready.
      TitError = "Error en la Impresora"
      TitSoluc1= "Verifique su impresora si est  en l¡nea o encedida"
      TitSoluc2= ""
   CASE ErrNum=1
      TitError = "Archivo no Existe"
      TitSoluc1= "Dele la Opci¢n de Mantenimiento y/o"
      TitSoluc2= " Restaure su Copia de Seguridad"
   CASE ErrNum=3
      TitError = "Archivo est  en Uso"
   CASE ErrNum=4
      TitError = "Posici¢n del Registro en Fin de Archivo"
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento "
      TitSoluc2= "de Archivos"
   CASE ErrNum=5
      TitError = "Registro esta fuera de Rango"
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento "
      TitSoluc2= "de Archivos"
   CASE ErrNum=6
      TitError = "Muchos Archivos Abiertos"
      TitSoluc1= "Incremente el No. de Files en su "
      TitSoluc2= "Archivos Config.sys y/o Config.fx"
   CASE ErrNum=7
      TitError = "Archivo Existente"
   CASE ErrNum=12
      IF " ORDER " $ UPPER(CURRERR)
         TitError = "Indice da¤ado en archivo "+dbf()
         TitSoluc1= "Ejecute la Opci¢n de Mantenimiento"
         TitSoluc2= "de Archivos"
      ENDIF
   CASE ErrNum=1707 .OR. ErrNum=1107 .AND. "INDEXA"$UPPER(CurrPrg)
      RETURN
   CASE ErrNum=1707 .OR. ErrNum=1107
      TitError = "Indice da¤ado en archivo "+dbf()
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento"
      TitSoluc2= "de Archivos"
   CASE ErrNum=15
      TitError = "No es un Archivo de Base de Datos"
   CASE ErrNum=19
      TitError = "Archivo Indice no pertenece a la Base de Datos"
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento"
      TitSoluc2= "de Archivos"
   CASE ErrNum=20
      TitError = "Registro no esta en el Archivo Indice"
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento"
      TitSoluc2= "de Archivos"
   CASE ErrNum=22
      TitError = "Muchas Variables de Memoria"
      TitSoluc1= "Incremente el MVCOUNT en el"
      TitSoluc2= "Archivo Config.fx"
   CASE ErrNum=26
      TitError = "Archivo no esta Indexado"
      TitSoluc1= "Ejecute la Opci¢n de Mantenimiento"
      TitSoluc2= "de Archivos"
   CASE ErrNum=39
      TitError = "Valor N£merico en Overflow"
   CASE ErrNum=43
      TitError = "Insuficiente memoria"
      TitSoluc1= "Redusca las Tareas del Computador"
      TitSoluc2= "o incremente al Memoria a su M quina"
   CASE ErrNum=56
      TitError = "No hay espacio suficiente en el Disco"
   CASE ErrNum=114
      TitError = "Indice da¤ado"
      TitSoluc1= "Probable Da¤o en Archivo"
      TitSoluc2= "Ejecute la Opci¢n de Mantenimiento"
   CASE ErrNum=1101
      TitError = "Archivo no puede ser Abierto"
      TitSoluc1= "Atributo del Lectura y Escritura del Archivo"
      TitSoluc2= "Inhabilitado para el Usuario"
   CASE ErrNum=1102
      TitError = "Archivo no puede ser Creado"
      TitSoluc1= "Atributo del Lectura y Escritura del Archivo"
      TitSoluc2= "Inhabilitado para el Usuario"
   CASE ErrNum=1104
      TitError = "Archivo con error en Lectura"
      TitSoluc1= "Probable Da¤o en Archivo"
      TitSoluc2= "Ejecute la Opci¢n de Mantenimiento"
   CASE ErrNum=1105
      TitError = "Archivo con error en Grabaci¢n"
      TitSoluc1= "Probable Da¤o en Archivo"
      TitSoluc2= "Ejecute la Opci¢n de Mantenimiento"
   CASE ErrNum=1112
      TitError = "Archivo no puede ser Cerrado"
      TitSoluc1= "Probable Da¤o en Archivo"
      TitSoluc2= "Ejecute la Opci¢n de Mantenimiento"
   CASE ErrNum=1113
      TitError = "Archivo no puede ser Abierto"
      TitSoluc1= "Probable Da¤o en Archivo"
      TitSoluc2= "Ejecute la Opci¢n de Mantenimiento"
   CASE ErrNum=1307
      TitError = "Divisi¢n entre cero"
   CASE ErrNum=1405
      TitError = "Error de Ejecuci¢n de Programa Externo"
      TitSoluc1= "Redusca las Tareas del Computador"
      TitSoluc2= "o incremente al Memoria a su M quina"
   CASE ErrNum=1503
      TitError = "Archivo no puede ser Asegurado"
   CASE ErrNum=1907
      TitError = "Invalido Drive especificado"
ENDCASE

SAVE SCREEN TO XError         && Guardar Pantalla
LenMax   = 0
LenMax   = IIF(LEN(TitError ) > LenMax ,LEN(TitError ) , LenMax)
LenMax   = IIF(LEN(TitSoluc1) > LenMax ,LEN(TitSoluc1) , LenMax)
LenMax   = IIF(LEN(TitSoluc2) > LenMax ,LEN(TitSoluc2) , LenMax)
LenMax   = IIF(LEN(TitProgr ) > LenMax ,LEN(TitProgr ) , LenMax)
LenMax   = IIF(LEN(TitComent) > LenMax ,LEN(TitComent) , LenMax)
LenMax   = LenMax+2
TitError = SUBSTR(SPACE(INT((LenMax-LEN(TitError ))/2))+TitError +SPACE(LenMax),1,LenMax)
TitSoluc1= SUBSTR(SPACE(INT((LenMax-LEN(TitSoluc1))/2))+TitSoluc1+SPACE(LenMax),1,LenMax)
TitSoluc2= SUBSTR(SPACE(INT((LenMax-LEN(TitSoluc2))/2))+TitSoluc2+SPACE(LenMax),1,LenMax)
TitProgr = SUBSTR(SPACE(INT((LenMax-LEN(TitProgr ))/2))+TitProgr +SPACE(LenMax),1,LenMax)
TitComent= SUBSTR(SPACE(INT((LenMax-LEN(TitComent))/2))+TitComent+SPACE(LenMax),1,LenMax)
Yo       = 9
Xo       = INT( (80 - LenMax)/2 )
IF _UNIX OR _DOS
	ACTIVATE SCREEN
ENDIF
SET CONSOLE   ON
SET DEVICE TO SCREEN
SET PRINT     OFF
SET TALK      OFF
@ Yo,Xo TO Yo+6,Xo+LenMax+1 COLOR SCHEME 7
@ Yo+1,Xo+1 SAY TitError    COLOR SCHEME 7
@ Yo+2,Xo+1 SAY TitSoluc1   COLOR SCHEME 7
@ Yo+3,Xo+1 SAY TitSoluc2   COLOR SCHEME 7
@ Yo+4,Xo+1 SAY TitProgr    COLOR SCHEME 7
@ Yo+5,Xo+1 SAY TitComent   COLOR SCHEME 7
DO WHILE .T.
   Tecla     = INKEY(0)
   DO CASE
      CASE Tecla = 13  && Enter
         EXIT
      CASE Tecla = 7   && Del
         EXIT
      CASE Tecla = 1   && Home
         EXIT
      CASE Tecla = 27  && Esc
         EXIT
      CASE Tecla = 6   && End
         EXIT
    ENDCASE
ENDDO
DO CASE
   CASE Tecla = 27         && Cancelar
      CLOSE DATA
      CLEAR GETS
      CLEAR PROMPT
      SET PRINT OFF
      RETURN TO MASTER
   CASE Tecla = 6          && Finalizar
      QUIT
   CASE Tecla = 1          && Suspender
      @ 22,0  CLEAR
      ? "=>"+CurrErr
      ? "Digite Resume para retornar"
      @ ROW(),7 SAY "RESUME"
      SUSPEND
ENDCASE
RESTORE SCREEN FROM XError
SET CONSOLE   &Syscnf100
SET DEVICE TO &Syscnf101
SET PRINT     &Syscnf102
IF Tecla = 7               && Ignorar
   RETURN
ELSE
   RETRY                   && Reintentar
ENDIF
**************
function Elige
**************
PARAMETERS OpcDef,Yo,Xo,LenVec
PRIVATE OpcAct,OpcVal,LenMax,j,Opcion,Yo2
IF _MAC OR _WINDOWS
	Yo2 = 2
ELSE
	Yo2 = 0
ENDIF
OpcAct = 1
OpcVal = []
LenMax = 0
LsOpcs = ""
IF PARAMETER() < 4
   LenVec = ALEN(VecOpc)
ENDIF
IF TYPE("OpcDef")="N"
   OpcAct = OpcDef
ENDIF
j = 1
DO WHILE j<=LenVec
   IF TYPE("OpcDef")="C"
      IF VecOpc(j) = OpcDef
         OpcAct    = j
      ENDIF
   ENDIF
   OpcVal    = OpcVal + LEFT(VecOpc(j),1)
   LenMax    = MAX(LEN(VecOpc(j)),LenMax)
   LsOpcs    = LsOpcs + VecOpc(J)+';'
   J = J + 1
ENDDO
OpcAct    = IIF(OpcAct > 0 .AND. OpcAct <= LenVec, OpcAct, 1)
LsFunction= "^RHT "+LsOpcs
LnUltimo= RAT(';',LsFunction)

IF LnUltimo>0
	LsFunction= LEFT(LsFunction,LnUltimo-1)
ENDIF
*Opcion = OpcAct
LsFunction = "'"+LsFunction+"'"
@ Yo-Yo2,Xo GET OpcAct FUNCTION &LsFunction. 
READ CYCLE MODAL
UltTecla = LASTKEY()

DO WHILE (_DOS OR _UNIX)
   Opcion = VecOpc(OpcAct)
   @ Yo,Xo SAY SPACE(LenMax)
   @ Yo,Xo GET Opcion 
   CLEAR GETS
   @ Yo,Xo SAY []
   Tecla  = INKEY(0)
   DO CASE
      CASE Tecla = 1   && Home
         OpcAct = 1
      CASE Tecla = 6   && End
         OpcAct = LenVec
      CASE Tecla = 4   && Derecha
         OpcAct  = IIF(OpcAct = LenVec, 1, OpcAct+1)
      CASE Tecla = 19  && Izquierda
         OpcAct  = IIF(OpcAct = 1, LenVec, OpcAct-1)
      CASE Tecla > 32
         Opcion = chr(Tecla)
         IF CHR(Tecla)$OpcVal
            OpcTmp = 0
            IF OpcAct < LENVEC
               OpcTmp  = AT(Opcion,SUBSTR(OpcVal,OpcAct+1,LenVec-OpcAct))
            ENDIF
            IF OpcTmp = 0
               OpcAct  = AT(Opcion,OpcVal)
            ELSE
               OpcAct  = OpcAct+OpcTmp
            ENDIF
         ELSE
            IF UPPER(Opcion)$OpcVal
               Opcion = UPPER(Opcion)
               OpcTmp = 0
               IF OpcAct < LenVec
                  OpcTmp  = AT(Opcion,SUBSTR(OpcVal,OpcAct+1,LenVec-OpcAct))
               ENDIF
               IF OpcTmp = 0
                  OpcAct  = AT(Opcion,OpcVal)
               ELSE
                  OpcAct  = OpcAct+OpcTmp
               ENDIF
            ENDIF
         ENDIF
                          ** Esc,F1,F10,Enter,Down,Up,PgUp,PgDn,^End,^Home,^PU,^PD,TAB,STAB **
      CASE LTRIM(STR(Tecla))$" 27,28, -9,   13,  24, 5,  18,   3,  29,   23, 31, 30,  9,  15"
         EXIT
   ENDCASE
ENDDO
IF _DOS OR _UNIX
	@ Yo,Xo SAY SPACE(LenMax)
	@ Yo,Xo SAY VecOpc(OpcAct)
ELSE 

ENDIF
UltTecla = LASTKEY()
IF TYPE("OpcDef")="N"
   RETURN OpcAct
ELSE
   RETURN VecOpc(OpcAct)
ENDIF

**** ENVIA CODIGOS DE CONTROL A LA IMPRESORA ****
function pset
*************
PARAMETER Num1,Num2
IF PARAMETER() < 1
   RETURN ""
ENDIF
DO CASE
   CASE Num1 = 0
      ??? _Prn0
   CASE Num1 = 1
      ??? _Prn1
   CASE Num1 = 2
      ??? _Prn2
   CASE Num1 = 3
      ??? _Prn3
   CASE Num1 = 4
      ??? _Prn4
   CASE Num1 = 5
      ??? _Prn5a+CHR(Largo)+_Prn5b
   CASE Num1 = 6
      IF PARAMETER() = 1 .OR. Num2 = 0
         ??? _Prn6a
      ELSE
         ??? _Prn6b
      ENDIF
   CASE Num1 = 7
      IF PARAMETER() = 1 .OR. Num2 = 0
         ??? _Prn7a
      ELSE
         ??? _Prn7b
      ENDIF
   CASE Num1 = 8
      IF PARAMETER() = 1 .OR. Num2 = 0
         ??? _Prn8a
      ELSE
         ??? _Prn8b
      ENDIF
   CASE Num1 = 9
      IF PARAMETER() = 1 .OR. Num2 = 0
         ??? _Prn9a
      ELSE
         ??? _Prn9b
      ENDIF
ENDCASE
RETURN ""
**************************************************************************
*  Nombre    : AdmUtPrn.PRG
*  Objeto    : Utilitarios de Impresi¢n
*  Par metros: Ninguno
**************************************************************************
procedure admutprn
CLEAR
@ 0,0 TO 23,79 PANEL
@ 0,27 SAY " UTILITARIOS DE IMPRESION " COLOR SCHEME 7

@  2, 4 SAY "                 "
@  3, 4 SAY "                 "
@  4, 4 SAY "                 "
@  5, 4 SAY "                 "
@  6, 4 SAY "                 "
@  7, 4 SAY "                 "
@  8, 4 SAY "                 "
@  9, 4 SAY "                 "
@ 10, 4 SAY "                 " COLOR SCHEME 7
@ 11, 4 SAY "                 " COLOR SCHEME 7
@ 12, 4 SAY "                 " COLOR SCHEME 7

*** Cargando el vector de archivos ***
xFile=SYS(2000,PathUser+"*.PRN")
IF xFile==""
   GsMsgErr = "No existen archivos de Impresi¢n"
   DO LIB_MERR WITH 99
   RETURN
ENDIF
DIMENSION vTabla(1)
vTabla(1) = xFile
i = 1
DO WHILE .T.
   xFile=SYS(2000,PathUser+"*.PRN",1)
   IF xFile==""
      EXIT
   ENDIF
   i = i + 1
   DIMENSION vTabla(i)
   vTabla(i) = xFile
ENDDO

Opc = 1
DO WHILE .T.
   @  4,30 GET i  FROM vTabla SIZE 16,20
   @  7,58 TO 11,71 DOUBLE
   @  7,59 SAY "Opciones" COLOR SCHEME 7
   @  8,60 GET Opc PICT "@*V \<Mostrar;\<Imprimir;\<Borrar"
   READ CYCLE
   IF LASTKEY() = 27 .OR. i=0
      RETURN
   ENDIF
   xFile = PathUser+vTabla(i)
   DO CASE
      CASE Opc = 1
         SAVE SCREEN
         **! readme &xFile
         MODI COMM (XfILE)
         RESTORE SCREEN
      CASE Opc = 2
         SAVE SCREEN TO xScr
         DO DIRPRINT  &&IN ADMPRINT
         IF LASTKEY() <> 27
            SET HEADING OFF
            SET CONSOLE OFF
            SET PDSETUP TO
            _PEJECT = "NONE"
            SET ESCAPE ON
            ON  ESCAPE RETURN
            DO PRINTEXT
            ON ESCAPE
            SET ESCAPE OFF
            SET CONSOLE ON
            SET HEADING ON
         ENDIF
         RESTORE SCREEN FROM xScr
      CASE Opc = 3
         DELETE FILE (xFile)
         =ADEL(vTabla,i)
         IF ALEN(vTabla) = 1
            RETURN
         ENDIF
         DIMENSION vTabla(ALEN(vTabla)-1)
         I = 1
   ENDCASE
ENDDO
RETURN

******************
PROCEDURE PRINTEXT
******************
TYPE (xFile) TO PRINT
RETURN
PARAMETERS Linea,Mensj1,Mensj2,Mensj3,HMnsj,CarVal,;
           Retardo,Bell,VSombra,Restituir
PRIVATE    Col,Tecla,dBTemp,Largo,TclFin,Len_Str,LenMax,Xo,Yo
PRIVATE    Cl_Str,Ancho
IF Bell
   ?? CHR(7)
ENDIF
IF Restituir
   SAVE SCREEN
ENDIF
LenMax = IIF(LEN(Mensj1)>LEN(Mensj2),LEN(Mensj1),LEN(Mensj2))
LenMax = IIF(LenMax>LEN(Mensj3),LenMax,LEN(Mensj3))
LenMax = IIF(LenMax<78,LenMax,78)
Largo  = 1
Cl_Str = TRIM(LTRIM(Mensj1))
Len_Str= INT((LenMax-LEN(Cl_Str))/2)
Mensj1 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),LenMax)

IF ! Mensj2==[]
   Largo  = 2
   Cl_Str = TRIM(LTRIM(Mensj2))
   Len_Str= INT((LenMax-LEN(Cl_Str))/2)
   Mensj2 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),;
   LenMax)
ENDIF

IF ! Mensj3==[]
   Largo  = 3
   Cl_Str = TRIM(LTRIM(Mensj3))
   Len_Str= INT((LenMax-LEN(Cl_Str))/2)
   Mensj3 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),;
   LenMax)
ENDIF

DO CASE
   CASE HMnsj = 1
      Col = 2
   CASE HMnsj = 2
      Col = 79 - LenMax
   CASE HMnsj = 3
      Col = INT((80-LenMax)/2)
ENDCASE

Yo    =  Linea
Xo    =  Col - 1
Ancho =  LenMax + 2
Largo =  Largo + 2

IF VSombra
   @ Yo+1,Xo-1,Yo+Largo+1,Xo+Ancho-1 BOX REPLICATE("°",12) COLOR SCHEME 11
ENDIF
@ Yo,Xo CLEAR TO Yo+Largo-1,Xo+Ancho-1 COLOR SCHEME 7
@ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 COLOR SCHEME 7
@ Linea+1,Col SAY Mensj1 COLOR SCHEME 7
@ Linea+2,Col SAY Mensj2 COLOR SCHEME 7
@ Linea+3,Col SAY Mensj3 COLOR SCHEME 7
*
Tecla     = 0
IF CarVal == []
   Tecla = INKEY(Retardo)
   TclFin  = []
ELSE
   DO WHILE .NOT.(UPPER(CHR(Tecla))$UPPER(CarVal))
       Tecla    = INKEY(0)
       Tecla    = IIF( Tecla < 0, 0, Tecla)
       Tecla    = IIF( Tecla > 255, Tecla-255, Tecla)
   ENDDO
   UltTecla = Tecla
   TclFin   = UPPER(CHR(Tecla))
ENDIF
*
* ------------------------------------------------------------------------
IF Restituir
   RESTORE SCREEN
ENDIF
RETURN TclFin
******************************************************************************
*  Nombre        : lib_merr.prg
*  Autor         : Ruben Hurtado
*  Proposito     : Muestra mensajes de error
*  Parametros    : LiMensaje ; numero del mensaje
*  Creacion      : 07/08/90
*  Actualizacion : 24/03/92  J.M.V.
******************************************************************************
procedure lib_merr
PARAMETERS nMensaje

PRIVATE cDesErr,sPanErr, nAncho, nCol
IF _dos OR _Unix
	SAVE SCREEN TO sPanErr
	@ 0,0 SAY []
	?? CHR(7)

ELSE

ENDIF
** MENSAJES GENERALES **
DO CASE
   CASE nMensaje = 1
      cDesErr = "Inicio de Archivo"
   CASE nMensaje = 2
      cDesErr = "Fin de Archivo"
   CASE nMensaje = 3
      cDesErr = "Acceso DENEGADO"
   CASE nMensaje = 4
      cDesErr = "Acceso es solo LECTURA"
   CASE nMensaje = 5
      cDesErr = "Registro Anulado"
   CASE nMensaje = 6
      cDesErr = "Dato Invalido"
   CASE nMensaje = 7
      cDesErr = "Fin del Archivo"
   CASE nMensaje = 8
      cDesErr = "Dato ya Registrado"
   CASE nMensaje = 9
      cDesErr = "Dato no Registrado"
   CASE nMensaje = 10
      cDesErr = "No existe el Correlativo"
   CASE nMensaje = 11
      cDesErr = "Registro creado por otro usuario"
   CASE nMensaje = 12
      cDesErr = "Registro NO puede ser Anulado"
   CASE nMensaje = 13
      cDesErr = "Cuenta NO afecta a Movimientos"
   CASE nMensaje = 14
      cDesErr = "Registro NO puede ser Modificado"
   CASE nMensaje = 15
      cDesErr = "Password Errado"
   CASE nMensaje = 16
      cDesErr = "Cliente no Corresponde"
   CASE nMensaje = 17
      cDesErr = "Documento Aprobado"
   CASE Type( "GsMsgErr" ) = "C"
      cDesErr = GsMsgErr
   OTHERWISE
   	IF _dos OR _Unix	
      RESTORE SCREEN FROM sPanErr
     ELSE 
      RETURN
     ENDIF 
ENDCASE
nAncho = LEN( cDesErr )
IF nAncho > 78
   nAncho = 78
   cDesErr = LEFT( cDesErr, 78 )
ENDIF

IF _dos OR _Unix	
@ 20,15 CLEAR TO 23,65
@ 20,15 FILL  TO 23,65 COLOR SCHEME 7
@ 20,15       TO 23,65 DOUBLE COLOR SCHEME 7
@ 21,40-LEN(cDesErr)/2 SAY cDesErr COLOR SCHEME 7
@ 22,24                SAY "Presione <SPACE> para continuar." COLOR SCHEME 7
	DO WHILE INKEY() <> ASC(" ")
	ENDDO
	RESTORE SCREEN FROM sPanErr
ELSE
	=MESSAGEBOX(cDesErr,16,'Atención')
ENDIF
RETURN
************************************************************************ FIN *
procedure busca
PARAMETERS Program,Key1,Key2,LinReg,Titulo,Yo,Xo,Largo,Ancho,TstLin
PRIVATE Inicio,Fin,Listar,Sigue,Ciclo,Ultimo,Actual,LeeReg,MaxLin,nSkip
PRIVATE HayEscLin,BUSCA,onCMD,LinIni,LinAct,RegAct
PRIVATE UltRegVal,ScrBusca
DIMENSION  Linea1(Largo-2), NumRg1(Largo-2)
SET TALK OFF
**** Ventana de Trabajo ***
SAVE SCREEN TO ScrBusca
IF Xo > 0 .AND. Yo+Largo < SROW()
   @ Yo+1,Xo-1 FILL  TO (Yo+Largo),(Xo+Ancho-2) COLOR W+/N
ENDIF
@ Yo,Xo CLEAR TO (Yo+Largo-1),(Xo+Ancho-1)
@ Yo,Xo FILL  TO (Yo+Largo-1),(Xo+Ancho-1) COLOR SCHEME 14
@ Yo,Xo TO (Yo+Largo-1),(Xo+Ancho-1) COLOR SCHEME 14
HayEscLin = IIF("" <> TRIM(LinReg), .F., .T.)
Sigue     = .T.
LeeReg    = .T.
UltRegVal = 0
MaxLin    = Largo-2
Actual    = 1
DO WHILE Sigue
   Listar   = .T.
   Inicio   = .F.
   Fin      = .F.
   Ciclo    = .T.
   Ultimo   = 0                          && Ultimo registro en la ventana.
   Actual   = 1                          && L¡nea activa.
   LinIni   = 0
   IF (! TRIM(Key1) == "")
      IF  ! RegVal() .OR. ! LeeReg
         Inicio   = .T.
         SEEK Key1
         IF ! FOUND()
            IF RECNO(0) > 0 .AND. RECNO(0)<=RECCOUNT()
               GOTO RECNO(0)
            ENDIF
         ENDIF
      ENDIF
   ELSE
      IF ! LeeReg .OR. EOF()
         Inicio   = .T.
         GOTO TOP
      ENDIF
   ENDIF
   IF LeeReg .AND. ! Inicio
     * RegAct = RECNO()
     * nSkip = MaxLin-1
     * DO Skip_Up WITH nSkip
     * Actual = MaxLin - nSkip
     * IF ! RegVal()
     *    GOTO RegAct
     *    Actual = 1
     * ENDIF
   ENDIF
   *IF ! TRIM(TstLin) == ""
   *   IF ! &TstLin .AND. RegVal()
   *      DO SKIP_DN WITH 1
   *   ENDIF
   *ENDIF
   LeeReg = .F.
   DO WHILE Ciclo
      IF Listar
         DO BPinta
      ENDIF
      @ Yo+1+LinIni,(Xo+Ancho-1) SAY IIF(Inicio ,"þ","") COLOR SCHEME 14
      @ Yo+Largo-2 ,(Xo+Ancho-1) SAY IIF(Fin    ,"þ","") COLOR SCHEME 14
      LinAct = Yo + Actual + LinIni
      IF Ultimo <> 0
         Contenido = Linea1(Actual)
         @ LinAct,Xo+1 SAY Contenido SIZE 1,Ancho-2 COLOR SCHEME 15
         IF ! Program==[]
            GOTO NumRg1(Actual)
            DO (Program)
         ENDIF
      ENDIF
      DO WHILE .T.
         Tecla  = INKEY(0)
         oNCMD  = ""
         DO CASE
            CASE Tecla = 13 .AND. ! ON("KEY","ENTER") == ""
               oNCmd = ON("KEY","ENTER")
            CASE Tecla = 13 .AND. Ultimo>0
               NumReg = NumRg1(Actual)
               GOTO NumReg
               Sigue = .F.
               Ciclo = .F.
               EXIT
            CASE Tecla = 27
               Sigue = .F.
               Ciclo = .F.
               EXIT
            CASE Tecla = 18     .AND. Ultimo > 0  && PgUp
               DO BPgUp
               EXIT
            CASE Tecla = 3      .AND. Ultimo > 0  && PgDn
               DO BPgDn
               EXIT
            CASE Tecla = 24     .AND. Ultimo > 0  && Down
               DO BDown
               EXIT
            CASE Tecla = 5      .AND. Ultimo > 0  && Up
               DO BUp
               EXIT
            CASE Tecla = 1                        && Home
               Ciclo  = .F.
               Actual = 1
               EXIT
            CASE Tecla = 6      .AND. Ultimo > 0  && End
               DO BEnd
               EXIT
            CASE Tecla = 32 .AND. ! ON("KEY","SPACEBAR") == ""
               oNCmd = ON("KEY","SPACEBAR")
            CASE Tecla = 7 .AND. ! ON("KEY","DEL") == ""
               oNCmd = ON("KEY","DEL")
            CASE Tecla = 22 .AND. ! ON("KEY","INS") == ""
               oNCmd = ON("KEY","INS")
            CASE Tecla = 19 .AND. ! ON("KEY","LEFTARROW") == ""
               oNCmd = ON("KEY","LEFTARROW")
            CASE Tecla = 4  .AND. ! ON("KEY","RIGHTARROW") == ""
               oNCmd = ON("KEY","RIGHTARROW")
            CASE Tecla = 9  .AND. ! ON("KEY","TAB") == ""
               oNCmd = ON("KEY","TAB")
            CASE Tecla = 15 .AND. ! ON("KEY","BACKTAB") == ""
               oNCmd = ON("KEY","BACKTAB")
            CASE Tecla = 28 .AND. ! ON("KEY","F1") == ""
               oNCmd = ON("KEY","F1")
            CASE Tecla = -1 .AND. ! ON("KEY","F2") == ""
               oNCmd = ON("KEY","F2")
            CASE Tecla = -2 .AND. ! ON("KEY","F3") == ""
               oNCmd = ON("KEY","F3")
            CASE Tecla = -3 .AND. ! ON("KEY","F4") == ""
               oNCmd = ON("KEY","F4")
            CASE Tecla = -4 .AND. ! ON("KEY","F5") == ""
               oNCmd = ON("KEY","F5")
            CASE Tecla = -5 .AND. ! ON("KEY","F6") == ""
               oNCmd = ON("KEY","F6")
            CASE Tecla = -6 .AND. ! ON("KEY","F7") == ""
               oNCmd = ON("KEY","F7")
            CASE Tecla = -7 .AND. ! ON("KEY","F8") == ""
               oNCmd = ON("KEY","F8")
            CASE Tecla = -8 .AND. ! ON("KEY","F9") == ""
               oNCmd = ON("KEY","F9")
            CASE Tecla = -9 .AND. ! ON("KEY","F10") == ""
               oNCmd = ON("KEY","F10")
         ENDCASE
         IF ! oNCMD == ""
            IF Actual > 0
               GOTO NumRg1(Actual)
            ENDIF
            &oNCMD
            IF _DOS OR _UNIX
	            ACTIVATE SCREEN
            ENDIF
            EXIT
         ENDIF
      ENDDO
   ENDDO
ENDDO
RESTORE SCREEN FROM ScrBusca
RETURN

****************
PROCEDURE BPinta
****************
PRIVATE LinTmp, nSkip
@ Yo+1,Xo+1 CLEAR TO (Yo+Largo-2),(Xo+Ancho-2)
@ Yo+1,Xo+1 FILL  TO (Yo+Largo-2),(Xo+Ancho-2) COLOR SCHEME  14
IF ! TRIM(Titulo)==""
   @ Yo+1,Xo+1 SAY Titulo SIZE 1,Ancho-2 COLOR SCHEME 14
   @ Yo+2,Xo+0 SAY "Ã" COLOR SCHEME 14
   @ Yo+2,Xo+1 TO Yo+2,Xo+Ancho-2 COLOR SCHEME 14
   @ Yo+2,Xo+Ancho-1 SAY "´" COLOR SCHEME 14
   LinIni = 2
   MaxLin = Largo - 4
ELSE
   LinIni = 0
   MaxLin = Largo - 2
ENDIF
LinTmp = 0
DO WHILE (LinTmp < MaxLin) .AND. RegVal() .AND. (! EOF())
   IF ! TRIM(TstLin) == ""
      IF ! &TstLin .AND. RegVal()
         nSkip = 1
         DO SKIP_DN WITH nSkip
         IF nSkip > 0
            EXIT
         ENDIF
      ENDIF
   ENDIF
   Contenido = []
   IF HayEscLin
      DO (EscLin) WITH Contenido
   ELSE
      Contenido  = &LinReg
   ENDIF
   LinTmp          = LinTmp + 1
   Linea1(LinTmp)  = Contenido
   NumRg1(LinTmp)  = RECNO()
   @ Yo+LinTmp+LinIni,Xo+1 SAY Linea1(LinTmp) SIZE 1,Ancho-2 COLOR SCHEME 14
   nSkip = 1
   DO Skip_Dn WITH nSkip
   IF nSkip > 0
      EXIT
   ENDIF
ENDDO
Fin    = ! (RegVal() .AND. (.NOT.EOF()))
IF ! TRIM(TstLin) == ""
   Fin    = Fin .AND. ! &TstLin
ENDIF
Ultimo = LinTmp
IF Ultimo = 0              && Ning£n registro seleccionado.
    NumRg1(1) = 0
ENDIF
LinTmp = LinTmp + 1
IF LinTmp  <= MaxLin
   @ Yo+LinTmp+LinIni,Xo+1 SAY "ð Fin "+REPLICATE("ð",Ancho-8) COLOR SCHEME 14
ENDIF
Listar = .F.
IF Actual > Ultimo
   Actual = Ultimo
ENDIF
RETURN

****************
PROCEDURE BDown
****************
@ Yo+Actual+LinIni,Xo+1 SAY Linea1(Actual) SIZE 1,Ancho-2 COLOR SCHEME 14
IF Actual=Ultimo
   GOTO NumRg1(Actual)
   nSkip = 1
   DO Skip_Dn WITH nSkip
   IF nSkip = 1
      RETURN
   ENDIF
   Fin =  ! (RegVal() .AND. (.NOT.EOF()))
   IF ! Fin
      Contenido = []
      IF HayEscLin
         DO (EscLin) WITH Contenido
      ELSE
         Contenido  = &LinReg
      ENDIF
      IF Actual = MaxLin
         j =1
         DO WHILE j < MaxLin
            Linea1(j)  = Linea1(j+1)
            NumRg1(j)  = NumRg1(j+1)
            j =j +1
         ENDDO
         Linea1(Actual)  = Contenido
         NumRg1(Actual)  = RECNO()
         SCROLL Yo+LinIni+1,Xo+1,Yo+Largo-2,Xo+Ancho-2,+1
         Ultimo = IIF( MaxLin > Ultimo, Ultimo+1, Ultimo)
         Inicio = .F.
      ELSE
         Actual=Actual+1
         Ultimo=Ultimo+1
         Linea1(Actual)  = Contenido
         NumRg1(Actual)  = RECNO()
      ENDIF
   ELSE
      ?? CHR(7)
   ENDIF
ELSE
   Actual=Actual+1
ENDIF

****************
PROCEDURE BUp
****************
@ Yo+Actual+LinIni,Xo+1 SAY Linea1(Actual) SIZE 1,Ancho-2 COLOR SCHEME 14
IF Actual > 1
   Actual = Actual -1
ELSE
   GOTO NumRg1(1)
   DO SKIP_UP WITH 1
   Inicio = ! (RegVal() .AND. ! BOF())
   IF ! Inicio
      j =MaxLin+1
      DO WHILE j >2
         j =j -1
         Linea1(j)  = Linea1(j-1)
         NumRg1(j)  = NumRg1(j-1)
      ENDDO
      Contenido = []
      IF HayEscLin
         DO &EscLin WITH Contenido
      ELSE
         Contenido  = &LinReg
      ENDIF
      Linea1(1)  = Contenido
      NumRg1(1)  = RECNO()
      SCROLL Yo+LinIni+1,Xo+1,Yo+Largo-2,Xo+Ancho-2,-1
      IF Ultimo=MaxLin
         Fin = .F.
      ENDIF
      Ultimo = IIF( MaxLin > Ultimo, Ultimo+1, Ultimo)
   ELSE
      ?? CHR(7)
   ENDIF
ENDIF

***************
PROCEDURE BPgUp
***************
@ Yo+Actual+LinIni,Xo+1 SAY Linea1(Actual) SIZE 1,Ancho-2 COLOR SCHEME 14
GOTO NumRg1(1)
UltRegVal = 0
nSkip = MaxLin
DO SKIP_Up WITH nSkip
Inicio = ! (RegVal() .AND. ! BOF())
Listar = .T.
IF Inicio
   IF UltRegVal > 0
      GOTO UltRegVal
   ELSE
      GOTO NumRg1(1)
   ENDIF
ENDIF
Actual = 1
RETURN

***************
PROCEDURE BPgDn
***************
@ Yo+Actual+LinIni,Xo+1 SAY Linea1(Actual) SIZE 1,Ancho-2 COLOR SCHEME 14
GOTO NumRg1(Ultimo)
DO SKIP_Dn WITH 1
IF (RegVal()) .AND. (.NOT. EOF())
   Inicio = .F.
   Listar = .T.
ELSE
   Actual = Ultimo
ENDIF
RETURN

****************
PROCEDURE BEnd
****************
PRIVATE NClave,XClave1,XClave2,Len1,Len2,Regpxm,nSkip
NClave = KEY(VAL(Sys(21)))
IF TRIM(Key2) == []
   GOTO BOTTOM
   Listar = .T.
ELSE
   XClave1 = Key2
   XClave2 = &NClave
   Len1    = LEN(XClave1)
   Len2    = LEN(XClave2)
   IF Len2>Len1
      XClave1 = XClave1+REPLICATE(CHR(255),Len2-Len1)
   ELSE
      IF Len2=Len1
         XClave1 = XClave1+CHR(255)
      ELSE
         XClave1 = LEFT(XClave1,Len2-1)+CHR(255)
      ENDIF
   ENDIF
   SEEK XClave1
   RegPxm = RECNO(0)
   Listar = .T.
   IF .NOT. FOUND()
      IF RegPxm = 0
         GOTO BOTTOM
         RegPxm = RECNO()
      ENDIF
      IF RegPxm>0 .AND. RegPxm<=RECCOUNT()
         GOTO RegPxm
         IF .NOT. (RegVal())
            SKIP -1
         ENDIF
         Listar = RegVal()
      ELSE
         Listar = .F.
      ENDIF
   ENDIF
ENDIF
IF Listar
   Inicio = .F.
   nSkip = MaxLin-1
   DO Skip_Up WITH nSkip
   Actual = MaxLin
ELSE
   Actual = Ulltimo
ENDIF
RETURN

*****************
PROCEDURE Skip_Up
*****************
PARAMETERS nSkip
PRIVATE J
J = 1
DO WHILE nSkip > 0 .AND. ! BOF()
   @ Yo+Largo-2,(Xo+Ancho-1) SAY SUBSTR("\³/-",j,1) COLOR SCHEME 14
   J = IIF(J=4,1,J+1)
   SKIP -1
   IF INKEY() = 32
      RETURN
   ENDIF
   IF ! RegVal() .OR. BOF()
      RETURN
   ENDIF
   IF ! TRIM(TstLin) == ""
      IF ! &TstLin
         LOOP
      ENDIF
   ENDIF
   UltRegVal = RECNO()
   nSkip = nSkip - 1
ENDDO
RETURN

*****************
PROCEDURE Skip_Dn
*****************
PARAMETERS nSkip
PRIVATE J
J = 1
IF ! TRIM(Titulo)==""
   LinIni = 2
ELSE
   LinIni = 0
ENDIF
DO WHILE nSkip > 0 .AND. ! EOF()
   @ Yo+1+LinIni,(Xo+Ancho-1) SAY SUBSTR("\³/-",j,1) COLOR SCHEME 14
   J = IIF(J=4,1,J+1)
   SKIP +1
   IF INKEY() = 32
      ?? CHR(7)
      RETURN
   ENDIF
   IF ! RegVal() .OR. EOF()
      RETURN
   ENDIF
   IF ! TRIM(TstLin) == ""
      IF ! &TstLin
         LOOP
      ENDIF
   ENDIF
   nSkip = nSkip - 1
ENDDO
RETURN

****************
PROCEDURE RegVal
****************
PRIVATE XClave
XClave = KEY(VAL(Sys(21)))
IF XClave == "" .OR. (Key1=="" .AND. Key2=="")
   RETURN ! EOF()
ENDIF
IF Key2 == ""
   Key2 = Key1
ENDIF
IF ! EVALUATE(XClave)>=Key1
   RETURN .F.
ENDIF
IF ! EVALUATE(XClave)<=Key2
   RETURN .F.
ENDIF
RETURN .T.
******************
procedure admcopia
******************
PARAMETERS DBFS
PRIVATE NumOpc
IF ! FILE(DBFS+".BAC")
   ?? CHR(7)
   GsMsgErr = "No Existe Indice de Archivos de copia"
   DO LIB_MERR WITH 99
   RETURN
ENDIF
* Pintando la Pantalla
ACTIVATE SCREEN
CLEAR
@ 0,0 TO 23,79 PANEL
@ 0,25 SAY " RESTAURAR COPIAS DE RESPALDO "
@  6,4  SAY "        Este proceso permite retornar la informaci¢n "
@  7,4  SAY "    de la copias de seguridad al disco duro.         "
@  8,4  SAY "    Inserte las unidades seg£n la secuencia que los  "
@  9,4  SAY "    solicite el sistema.                             "
@ 10,4  SAY "        Al concluir esta opci¢n ejecute seguidamente "
@ 11,4  SAY "    la opci¢n de mantenimiento de archivos.          "
@ 12,4  SAY "        Este proceso realiza una apertura de archivo "
@ 13,4  SAY "    exclusiva por tanto deber  ser  la  £nica  tarea "
@ 14,4  SAY "    que se efectue sobre el sistema.                 "
@ 15,4  SAY "                                                     "
@ 15,5  SAY "                                                     "
@ 16,4  SAY "                                                     "

Drive = "A:"
@ 17,31 TO 21,69
@ 18,36 SAY "Unidad de Grabaci¢n : " GET Drive PICT "@^ A:;B:"
READ
IF LASTKEY()=27
   CLOSE DATA
   RETURN
ENDIF

IF FILE(DBFS+".ARC")
   DELETE FILE &DBFS..ARC
ENDIF
@ 14,0 TO 14,79
@ 15,0 CLEAR
SAVE SCREEN
@ 19,20 FILL TO 22,57 COLOR W+/N
@ 18,21 SAY "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" COLOR SCHEME 7
@ 19,21 SAY "³Inserte su Diskette en la unidad "+Drive+" ³" COLOR SCHEME 7
@ 20,21 SAY "³  Presione <Enter> para continuar   ³" COLOR SCHEME 7
@ 21,21 SAY "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ" COLOR SCHEME 7
DO WHILE ! INKEY(0)=13
ENDDO
@ 15,0 CLEAR
! RESTORE &Drive . /S
RESTORE SCREEN
! PKUNPAK &DBFS
WAIT "Proceso de Restauraci¢n Completado" NOWAIT WINDOW
CLOSE DATA
RETURN
*!*********************************************************************
*!
*!      Procedure: ALRT
*!
*!*********************************************************************
PROCEDURE alrt
PARAMETER m.message
PRIVATE m.remove


DEFINE WINDOW _pvz0lhvmg ;
        FROM INT((SROW()-7)/2),INT((SCOL()-50)/2) ;
        TO INT((SROW()-7)/2)+6,INT((SCOL()-50)/2)+49 ;
        FLOAT ;
        NOCLOSE ;
        SHADOW ;
        DOUBLE ;
        COLOR SCHEME 7

ACTIVATE WINDOW _pvz0lhvmg

m.remove = 1

@ 1,0 SAY PADC(m.message, 48, " ")
@ 4,17 GET m.remove ;
        PICTURE "@*HT \!\<Continuar" ;
        SIZE 1,12,10 ;
        DEFAULT 1

READ CYCLE MODAL


RELEASE WINDOW _pvz0lhvmg

RETURN LASTKEY() <> 27

******************
procedure admresta
******************
PARAMETERS DBFS
PRIVATE NumOpc
IF ! FILE(DBFS+".BAC")
   ?? CHR(7)
   GsMsgErr = "No Existe Indice de Archivos de copia"
   DO LIB_MERR WITH 99
   RETURN
ENDIF
* Pintando la Pantalla
ACTIVATE SCREEN
CLEAR
@ 0,0 TO 23,79 PANEL
@ 0,30 SAY " COPIAS DE RESPALDO "
@  6,4  SAY "         Este proceso tiene por finalidad el de tener "
@  7,4  SAY "     copias de seguridad de la informaci¢n registrada "
@  8,4  SAY "     en el disco duro en unidades de grabaci¢n flexi- "
@  9,4  SAY "     fles (diskette).                                 "
@ 10,4  SAY "         Asegurese que los  diskettes  a  usar  esten "
@ 11,4  SAY "     formateados.                                     "
@ 12,4  SAY "         Este proceso realiza una apertura de archivo "
@ 13,4  SAY "     exclusiva por tanto deber  ser  la  £nica  tarea "
@ 14,4  SAY "     que se efectue sobre el sistema.                 "
@ 15,4  SAY "                                                      "
@ 15,5  SAY "                                                      "
@ 16,4  SAY "                                                      "

Drive = "A:"
@ 17,31 TO 21,69
@ 18,36 SAY "Unidad de Grabaci¢n : " GET Drive PICT "@^ A:;B:"
READ
IF LASTKEY()=27
   CLOSE DATA
   RETURN
ENDIF

IF FILE(DBFS+".ARC")
   DELETE FILE &DBFS..ARC
ENDIF
@ 14,0 TO 14,79
@ 15,0 CLEAR
SAVE SCREEN
! PKPAK -A &DBFS  @&DBFS..BAC
RESTORE SCREEN
@ 19,20 FILL TO 22,57 COLOR W+/N
@ 18,21 SAY "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" COLOR SCHEME 7
@ 19,21 SAY "³Inserte su Diskette en la unidad "+Drive+" ³" COLOR SCHEME 7
@ 20,21 SAY "³  Presione <Enter> para continuar   ³" COLOR SCHEME 7
@ 21,21 SAY "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ" COLOR SCHEME 7
DO WHILE ! INKEY(0)=13
ENDDO
@ 15,0 CLEAR
! BACKUP &DBFS..ARC &Drive
IF FILE(DBFS+".ARC")
   DELETE FILE &DBFS..ARC
ENDIF
WAIT "Copia de Respaldo Completado" NOWAIT WINDOW
CLOSE DATA
RETURN
******************
procedure admgnprn
******************
CLEAR
@ 1,0 SAY "IMPRESORAS CONECTADAS AL TERMINAL" COLOR SCHEME 7
@ 2,0 SAY "                                 " PICT "@I" COLOR SCHEME 7


USE ADMPRINT ORDER ADMPRINT EXCL
DIMENSION vDriver(9)
vDriver(1) = "Epson   "
vDriver(2) = "EpsonMx "
vDriver(3) = "IBM     "
vDriver(4) = "Mt180   "
vDriver(5) = "Genicom "
vDriver(6) = "LJet1H  "
vDriver(7) = "LJet2H  "
vDriver(8) = "LJet1V  "
vDriver(9) = "LJet2V  "
Set_Escape = .T.
UltTecla = 0
SelLin   = "SELLINzz"
InsLin   = "GRABAzz"
EscLin   = ""
EdiLin   = "EDITAzz"
BrrLin   = "BORRAzz"
GrbLin   = "GRABAzz"
NClave   = [Terminal]
VClave   = GsTerminal
HTitle   = 3
MVprgF1  = []
MVprgF2  = []
MVprgF3  = []
MVprgF4  = []
MVprgF5  = []
MVprgF6  = []
MVprgF7  = []
MVprgF8  = []
MVprgF9  = []
Yo       = 3
Largo    = 18
TBorde   = Simple
TITULO   = ""
E1       = [ #      I M P R E S O R A         ]
E2       = []
E3       = []
LinReg   = [ID+" "+Nombre]
Ancho    = LEN(&LinReg.)+4
Xo       = 80-Ancho
Consulta = .F.
Modifica = .T.
Adiciona = .T.
Static   = .F.
VSombra  = .T.

*** Variables a usar ****
LcId        = ""
DO LIB_MTEC WITH 14
do sellinzz
DO DBrowse
PACK
SEEK GsTerminal
IF FOUND()
   _Nombre    = Nombre
   _Interface = Interface
   _Comando   = Comando
   _Driver    = TRIM(Driver)+".pdt"
   IF "" <> _Comando
      ! &_Comando >nul
   ENDIF
   IF "" <> _Interface
      SET PRINT TO (_Interface)
   ELSE
      SET PRINT TO
   ENDIF
ENDIF

CLOSE DATA
RETURN

******************************************************************************
PROCEDURE SELLINzz
****************
@ 8,0 TO 17,41 PANEL
@ 10,3 SAY "Interface      : ["+Interface+"]"
@ 12,3 SAY "Printer Driver : ["+Driver+"]"
@ 14,1 TO 16,40
@ 14,12 SAY "COMANDO DE ACTIVACION" COLOR SCHEME 7
@ 15,2 SAY Comando         PICT "@S38"
RETURN

******************************************************************************
PROCEDURE EDITAzz
***************
DO LIB_MTEC WITH 7

IF ! Crear
   LcId       = Id
   _Nombre    = Nombre
   _Interface = Interface
   _Comando   = Comando
   _Driver    = Driver
ELSE
   LcId       = Id
   _Nombre    = Nombre
   _Interface = SPACE(LEN(Interface))
   _Comando   = SPACE(LEN(Comando))
   _Driver    = "Epson   "
ENDIF

@ LinAct,Xo+2  GET LcId  PICT "9"
@ LinAct,Xo+4  GET _Nombre
@ 10,21  GET _Interface      PICT "@!"
@ 12,21  GET _Driver         VALID xDriver()
@ 15,2   GET _Comando        PICT "@S38"
READ
UltTecla = LASTKEY()
DO LIB_MTEC WITH 14
RETURN

***************
PROCEDURE BORRAzz
***************
UltTecla = 0
IF RLOCK()
   DELETE
   UNLOCK
   UltTecla = F10
ELSE
   UltTecla = Escape
ENDIF
RETURN

***************
PROCEDURE GRABAzz
***************
IF Crear
   APPEND BLANK
ENDIF
IF ! RLOCK()
   UltTecla = Escape
   RETURN
ENDIF
REPLACE Terminal  WITH GsTerminal
REPLACE ID        WITH LcID
REPLACE Nombre    WITH _Nombre
REPLACE Interface WITH _Interface
REPLACE Comando   WITH _Comando
REPLACE Driver    WITH _Driver
UNLOCK
RETURN

*****************
PROCEDURE xDriver
*****************
PRIVATE xOpc
IF LASTKEY() = -7
   SAVE SCREEN
   xOpc = 1
   @ 12,21 GET xOpc FROM vDriver SIZE 10,12
   READ
   RESTORE SCREEN
   IF LASTKEY() <> 27
      _Driver = vDriver(xOpc)
      RETURN .T.
   ENDIF
   RETURN .F.
ENDIF
FOR xOpc=1 TO ALEN(vDriver)
   IF Upper(_Driver) = Upper(vDriver(xOpc))
      _Driver = vDriver(xOpc)
      RETURN .T.
   ENDIF
ENDFOR
RETURN .F.
******************************************************************************
*  Nombre        : lib_msgs.prg
*  Autor         :
*  Proposito     : Muestra mensaje de ayuda
*  Parametros    : LiMensaje ; numero del mensaje
*  Creacion      :
*  Actualizacion :
******************************************************************************
procedure lib_msgs
PARAMETERS nMensaje
PRIVATE cDesMsg
cDesMsg = ""
DO CASE
   CASE nMensaje = 1
      cDesMsg = "Ingrese c¢digo principal de busqueda"
   CASE nMensaje = 2
      cDesMsg = "Ingrese los datos solicitados"
   CASE nMensaje = 3
      cDesMsg = "Procesando informaci¢n. Un momento por favor.."
   CASE nMensaje = 4
      cDesMsg = "Grabando en archivos. Un momento por favor.."
   CASE nMensaje = 5
      cDesMsg = "Totalizando registros. Un momento por favor.."
   CASE nMensaje = 6
      cDesMsg = "Operaci¢n cancelada"
   CASE nMensaje = 7
      cDesMsg = "Seleccione con las teclas direccionales el registro buscado"
   CASE nMensaje = 8
      cDesMsg = "Mensaje Pendiente consultar ?"
   CASE nMensaje = 9
      cDesMsg = "Transfiriendo informaci¢n. Un momento por favor.."
   CASE nMensaje = 10
      cDesMsg = "Borrando registro. Un momento por favor.."
   CASE nMensaje = 11
      cDesMsg = "Aperturando Archivos. Un momento por favor.."
   CASE nMensaje = 12
      cDesMsg = "Inicializando Procesos. Un momento por favor.."
   CASE nMensaje = 13
      cDesMsg = ""
      SET COLOR TO &Color_1
      @ ROW()  ,11 SAY "     #    #     # #     # #          #    ######  #######  "
      @ ROW()+1,11 SAY "    # #   ##    # #     # #         # #   #     # #     #  "
      @ ROW()+1,11 SAY "   #   #  # #   # #     # #        #   #  #     # #     #  "
      @ ROW()+1,11 SAY "  #     # #  #  # #     # #       #     # #     # #     #  "
      @ ROW()+1,11 SAY "  ####### #   # # #     # #       ####### #     # #     #  "
      @ ROW()+1,11 SAY "  #     # #    ## #     # #       #     # #     # #     #  "
      @ ROW()+1,11 SAY "  #     # #     #  #####  ####### #     # ######  #######  "
   CASE Type( "GsMsgAlt" ) = "C"
      cDesErr = GsMsgAlt
ENDCASE
@ 24,0
if nMensaje <> 0
   @ 24,40-LEN(cDesMsg)/2 SAY cDesMsg COLOR W*/N
ENDIF
RETURN
************************************************************************ FIN *
**************************************************************************
*  Consulta y modificaci¢n de tablas
**************************************************************************
function tabla
PARAMETER XsTabla,VarAsg,xDigitos
PRIVATE XsCodigo , XsNombre, nSelect, Titulo, nDigitos
PRIVATE nSelect, Xo, Yo, Largo, Ancho, LinReg, Key1, Key2
PRIVATE Desde,Hasta,LsNombre,Sorteo,Localiza,cPicture,Completa
SAVE SCREEN to xTabla
GsMsgKey = "[T.Cursor]Posic. [F2]Modif. [F5]Ubica [F6]Lista [Ins]Adic. [Del]Borra [Enter]Tomar [Esc]Canc."
DO Lib_MTEC with 99
nSelect = SELECT()
IF TYPE("xDigitos")<>"L"
   xDigitos = .F.
ENDIF
SELECT TABL
SET ORDER TO TABL01
PUSH KEY CLEAR
ON KEY LABEL F2  DO XF2
ON KEY LABEL F4  DO XF4
ON KEY LABEL F5  DO XF5
ON KEY LABEL F6  DO XF6
ON KEY LABEL INS DO XINS
ON KEY LABEL DEL DO XDEL
SEEK "00"+XsTabla
nDigitos = IIF(Digitos>0,Digitos,LEN(Codigo))
IF SUBSTR(Codigo,3,1)="N"
   cPicture = REPLICATE("9",nDigitos)
   Completa = .F.
   IF SUBSTR(Codigo,4,1)="N"
      Completa = .T.
   ENDIF
ELSE
   cPicture = REPLICATE("!",nDigitos)
   Completa = .F.
ENDIF
STORE SPACE(nDigitos) TO Desde,Hasta,LsNombre
Key1     = XsTabla
Key2     = XsTabla
Sorteo   = 1
Localiza = .F.
Yo       = 8
Largo    = 14
LinReg   = "LEFT(Codigo,nDigitos)+' '+LEFT(Nombre,30)"
IF xDigitos
   LinReg   = "LEFT(Codigo,nDigitos)+' '+LEFT(Nombre,30)+' '+TRANS(Digitos,'@Z ##')"
ENDIF
Ancho    = Len(&LinReg)+2
Xo       = 80-Ancho
Titulo = PADC(TRIM(Nombre),Ancho-2)
DO Busca WITH "",Key1,Key2,LinReg,Titulo,Yo,Xo,Largo,Ancho,""
POP KEY
IF LASTKEY() <> 27
   VarAsg = LEFT(Codigo,LEN(VarAsg))
   @ 24,0 SAY VarAsg
ENDIF
SET ORDER TO TABL01
SELECT (nSelect)
RESTORE SCREEN FROM xTabla
RETURN

**************
PROCEDURE XINS
**************
PRIVATE XsCodigo,XsNombre,Yo2,Xo2
PUSH KEY CLEAR
XsCodigo = SPACE(nDigitos)
XsNombre = SPACE(LEN(Nombre))
XiDigito = 0
Xo2      = Xo+nDigitos+2
Yo2      = LinAct
SAVE SCREEN
@ LinAct-1,Xo CLEAR TO LinAct+1,Xo+Ancho-1
@ LinAct-1,Xo,LinAct+1,Xo+Ancho-1 BOX "ÚÄ·º¼ÍÔ³"
@ Yo2,Xo+1   GET XsCodigo PICT cPicture
@ Yo2,Xo2    GET XsNombre PICT "@!S30"
IF xDigitos
   @ Yo2,Xo2+31 GET XiDigito PICT "@Z ##"
ENDIF
READ
POP KEY
Listar = .T.
IF LASTKEY() <> 27
   APPEND BLANK
   IF RLOCK()
      REPLACE Tabla   WITH XsTabla
      REPLACE Codigo  WITH XsCodigo
      REPLACE Nombre  WITH XsNombre
      REPLACE Digitos WITH XiDigito
      Ciclo  = .F.
      LeeReg = .T.
   ENDIF
ENDIF
RESTORE SCREEN
RETURN

**************
PROCEDURE XDEL
**************
PRIVATE Opc = 1
Opc = 1
SAVE SCREEN
@ 19,19 TO 22,42 COLOR SCHEME 7
@ 20,20 SAY "¨ Anular el registro ?" COLOR SCHEME 7
@ 21,20 SAY "                      " COLOR SCHEME 7
@ 21,22 GET Opc PICT "@*H Cancelar;Anular" COLOR SCHEME 7
READ
RESTORE SCREEN
IF LASTKEY() = 27 .OR. Opc = 1
   RETURN
ENDIF
IF RLock()
   DELETE
   UNLOCK
   SKIP
   Leereg = .T.
   Ciclo  = .F.
ENDIF
RETURN

*************
PROCEDURE XF2
*************
PRIVATE XsCodigo,XsNombre,Yo2
IF Actual <= 0
   RETURN
ENDIF
PUSH KEY CLEAR
XsCodigo = LEFT(Codigo,nDigitos)
XsNombre = Nombre
XiDigito = Digitos
Xo2 = Xo+nDigitos+2
@ LinAct,Xo+1 GET XsCodigo PICT cPicture COLOR SCHEME 7
@ LinAct,Xo2  GET XsNombre PICT "@S30" COLOR SCHEME 7
IF xDigitos
   @ LinAct,Xo2+31 GET XiDigito PICT "@Z ##"
ENDIF
READ
POP KEY
IF LASTKEY() <> 27
   IF Completa
      XsCodigo = RIGHT(REPLICATE("0",nDigitos)+LTRIM(XsCodigo),nDigitos)
   ENDIF
   IF RLOCK()
      REPLACE Codigo  WITH XsCodigo
      REPLACE Nombre  WITH XsNombre
      REPLACE Digitos WITH XiDigito
      Linea1(Actual) = &LinReg
   ENDIF
ENDIF
RETURN


*************
PROCEDURE XF4
*************
IF ! Localiza
   RETURN
ENDIF
CONTINUE
IF FOUND()
   Listar = .t.
ELSE
  ?? CHR(7)
ENDIF

*************
PROCEDURE XF5
*************
SAVE SCREEN
PUSH KEY CLEAR
LsNombre = SPACE(LEN(Nombre))
@ 13,1 CLEAR TO 22,34
@ 14,1,22,33 BOX "Û   ßßßÛ" COLOR SCHEME 11
@ 13,2 TO 21,34 DOUBLE
@ 14,12 SAY "Ordenado : " GET Sorteo PICT "@^ C¢digo;Nombre"
READ
IF LASTKEY() = 27
   RETURN
ENDIF
Localiza = .f.
IF Sorteo = 1
   SET ORDER TO TABL01
   STORE SPACE(nDigitos) TO Desde,Hasta
ELSE
   SET ORDER TO TABL02
   STORE SPACE(LEN(Nombre)) TO Desde,Hasta
ENDIF
@ 17,4  SAY "Desde : " GET Desde  PICT "@!S20"
@ 18,4  SAY "Hasta : " GET Hasta  PICT "@!S20"
@ 19,4  SAY "Localizar : " GET LsNombre  PICT "@!S15"
READ
Ciclo = .F.
Key1   = XsTabla + TRIM(Desde)
Key2   = XsTabla + TRIM(Hasta)
IF ! EMPTY(LsNombre)
   SEEK Key1
   Localiza  = .t.
   IF Sorteo = 1
      LOCATE WHILE TABLA+CODIGO<=Key2 FOR TRIM(LsNombre)$UPPER(Nombre)
   ELSE
      LOCATE WHILE TABLA+NOMBRE<=Key2 FOR TRIM(LsNombre)$UPPER(Nombre)
   ENDIF
   LeeReg = FOUND()
ENDIF
POP KEY
RESTORE SCREEN
RETURN

*************
PROCEDURE XF6
*************
PUSH KEY CLEAR
SAVE SCREEN TO XF6
sNomRep="Tabla"
IF Sorteo = 1
   xWhile = "Tabla+Codigo<=Key2"
ELSE
   xWhile = "Tabla+Nombre<=Key2"
ENDIF
xFor   = ""
IniPrn = _Prn0+_Prn5a+CHR(66)+_Prn5b+_Prn1
SEEK Key1
DO ADMPRINT WITH "REPORTS"
POP KEY
RESTORE SCREEN FROM XF6
RETURN
**************
function fondo
**************
PARAMETER cTit1,cTit2,cTit3,cTit4
DO CASE 
	CASE  _DOS OR _UNIX
		FOR i = 0 TO SROW()-1
		  @ i,0 SAY REPLICATE("°",SCOL()) COLOR SCHEME 11
		ENDFOR
		@ 0,1 CLEAR TO 3,SCOL()-2
		@ 0,1 FILL  TO 3,SCOL()-2 COLOR SCHEME 7
		@ 0,1       TO 3,SCOL()-2 COLOR SCHEME 7
		@ 1,0 FILL  TO 4,0        COLOR W/N
		@ 4,0 FILL  TO 4,SCOL()-3 COLOR W/N
		@ 1,3 SAY  cTit1 COLOR SCHEME 7
		@ 2,3 SAY  cTit2 COLOR SCHEME 7
		@ 1,SCOL()-LEN(cTit3)-3 SAY cTit3 COLOR SCHEME 7
		@ 2,SCOL()-LEN(cTit4)-3 SAY cTit4 COLOR SCHEME 7
	CASE _WINDOWS 	OR _MAC 
		
*!*			FOR k = 1 TO 24
*!*			ctit1='SCHEME_'+STR(k)
*!*			sc= 'COLOR SCHEME '+STR(k)
		DEFINE WINDOW __WFondo AT 05,10 SIZE 40,90 CLOSE FLOAT GROW ;
			 TITLE (cTit1) COLOR SCHEME 16
			 
		ACTIVATE WINDOW __WFondo
*!*			@ 10,10 say 'hola' get xs default 'Prueba'
*!*			READ 

*!*			ENDFOR
		
ENDCASE 	
RETURN
*************
function ntod
*************
PARAMeTER Num
PRIVATE xNum
SET DATE BRIT
xNum=TRANSF(M->Num,"@L ######")
return CTOD(LEFT(xNum,2)+"/"+SUBSTR(xNum,3,2)+"/"+RIGHT(xNum,2))
*!*	******************
*!*	procedure admm0000
*!*	******************
*!*	SET TALK OFF
*!*	RELEASE ALL LIKE m_op?
*!*	DIMENSION m_op0(4,2)
*!*	DIMENSION m_op2(2)

*!*	m_op0( 1, 1) = "IMPRESORAS"
*!*	m_op0( 2, 1) = "BACKUP GENERAL"
*!*	m_op0( 3, 1) = "USUARIOS"
*!*	m_op0( 4, 1) = "TERMINAL"

*!*	m_op0( 1, 2) = " Administraci¢n de Impresoras "
*!*	m_op0( 2, 2) = " Respaldo de Archivos Generales "
*!*	m_op0( 3, 2) = " Actualizaci¢n de Usuarios del Sistema"
*!*	m_op0( 4, 2) = " Instalar un nuevo terminal al Sistema"

*!*	m_op2(1) = "Generaci¢n de la Copia "
*!*	m_op2(2) = "Recuperaci¢n  la  Copia"

*!*	Row = 1
*!*	Col = 1
*!*	DO WHILE .T.
*!*	   SET PROCEDURE TO
*!*	   CLEAR
*!*	   @  6,12 SAY "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂ¿" COLOR SCHEME 7
*!*	   @  7,12 SAY "ÃÄÜÛÛÛÛÜÄÄÄÄÛÛÄÄÄÄÄÄÄÄÄÄÄÄ´                            Ã´" COLOR SCHEME 7
*!*	   @  8,12 SAY "ÃÄÛÛÄÄÛÛÄÄÜÜÛÛÄÛÛÜÛÛÜÛÛÜÄÄ´                            Ã´" COLOR SCHEME 7
*!*	   @  9,12 SAY "ÃÄÛÛÛÛÛÛÄÛÛßÛÛÄÄÛÛßÛÛßÛÛÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁ´" COLOR SCHEME 7
*!*	   @ 10,12 SAY "ÃÄÛÛÄÄÛÛÄÛÛÄÛÛÄÄÛÛÄÛÛÄÛÛÄ                               ³" COLOR SCHEME 7
*!*	   @ 11,12 SAY "ÃÄÛÛÄÄÛÛÄßÛÛÛÛÄÄÛÛÄÛÛÄÛÛÄßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß´" COLOR SCHEME 7
*!*	   @ 12,12 SAY "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ" COLOR SCHEME 7
*!*	   @ 13,21 SAY LEFT(GsNomCia+SPACE(38),38)               PICTURE "@I" SIZE 1,38 COLOR SCHEME 11
*!*	   @ 14,21 SAY " Modulo : Administrador  V.1.0/1993  "   PICTURE "@I" SIZE 1,38 COLOR SCHEME 11
*!*	   @ 17,21 SAY LEFT("Terminal "+GsTerminal+SPACE(38),38) PICTURE "@I" SIZE 1,38 COLOR SCHEME 11
*!*	   @ 21,0 TO 21,79
*!*	   @ 23,0 TO 23,79

*!*	   GsMsgKey = "[Teclas del Cursor] Escoge opci¢n    [Enter] Selecciona    [Esc] Cancela"
*!*	   DO LIB_MTEC WITH 99
*!*	   SET MESSAGE TO 22
*!*	   MENU BAR m_op0,4
*!*	   MENU  2,m_op2,2
*!*	   READ MENU BAR TO Row, Col
*!*	   DO CASE
*!*	      CASE row = 0
*!*	         RETURN
*!*	      CASE row = 1
*!*	         DO ADMGNPRN
*!*	      CASE row = 2
*!*	         DO CASE
*!*	            CASE col = 1
*!*	               DO ADMCOPIA WITH "GENLISTA"
*!*	            CASE col = 2
*!*	               DO ADMRESTA WITH "GENLISTA"
*!*	         ENDCASE
*!*	      CASE row = 3
*!*	         DO ADMGUSER
*!*	      CASE row = 4
*!*	         DO INSTALL IN ADMMUSER
*!*	   ENDCASE
*!*	ENDDO
*!*	RETURN
***************
function prnstr
***************
set margin to 10
list stru to print
n = 1
do while ! sys(14,n)==""
   SET ORDER TO N
   ??? SPACE(10)+ORDER()+" "+sys(14,n)+chr(13)+chr(10)
   n = n + 1
enddo
eject page
***********
PROCE AVISO
************
PARAMETERS Linea,Mensj1,Mensj2,Mensj3,HMnsj,CarVal,;
           Retardo,Bell,VSombra,Restituir
PRIVATE    Col,Tecla,dBTemp,Largo,TclFin,Len_Str,LenMax,Xo,Yo
PRIVATE    Cl_Str,Ancho
IF Bell
   ?? CHR(7)
ENDIF
IF Restituir
   SAVE SCREEN
ENDIF
LenMax = IIF(LEN(Mensj1)>LEN(Mensj2),LEN(Mensj1),LEN(Mensj2))
LenMax = IIF(LenMax>LEN(Mensj3),LenMax,LEN(Mensj3))
LenMax = IIF(LenMax<78,LenMax,78)
Largo  = 1
Cl_Str = TRIM(LTRIM(Mensj1))
Len_Str= INT((LenMax-LEN(Cl_Str))/2)
Mensj1 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),LenMax)

IF ! Mensj2==[]
   Largo  = 2
   Cl_Str = TRIM(LTRIM(Mensj2))
   Len_Str= INT((LenMax-LEN(Cl_Str))/2)
   Mensj2 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),;
   LenMax)
ENDIF

IF ! Mensj3==[]
   Largo  = 3
   Cl_Str = TRIM(LTRIM(Mensj3))
   Len_Str= INT((LenMax-LEN(Cl_Str))/2)
   Mensj3 = LEFT(IIF(Len_Str>0,SPACE(Len_Str)+Cl_Str+SPACE(LenMax),Cl_Str),;
   LenMax)
ENDIF

DO CASE
   CASE HMnsj = 1
      Col = 2
   CASE HMnsj = 2
      Col = 79 - LenMax
   CASE HMnsj = 3
      Col = INT((80-LenMax)/2)
ENDCASE

Yo    =  Linea
Xo    =  Col - 1
Ancho =  LenMax + 2
Largo =  Largo + 2

IF VSombra
   @ Yo+1,Xo-1,Yo+Largo+1,Xo+Ancho-1 BOX REPLICATE("°",12) COLOR SCHEME 11
ENDIF
@ Yo,Xo CLEAR TO Yo+Largo-1,Xo+Ancho-1 COLOR SCHEME 7
@ Yo,Xo TO Yo+Largo-1,Xo+Ancho-1 COLOR SCHEME 7
@ Linea+1,Col SAY Mensj1 COLOR SCHEME 7
@ Linea+2,Col SAY Mensj2 COLOR SCHEME 7
@ Linea+3,Col SAY Mensj3 COLOR SCHEME 7
*
Tecla     = 0
IF CarVal == []
   Tecla = INKEY(Retardo)
   TclFin  = []
ELSE
   DO WHILE .NOT.(UPPER(CHR(Tecla))$UPPER(CarVal))
       Tecla    = INKEY(0)
       Tecla    = IIF( Tecla < 0, 0, Tecla)
       Tecla    = IIF( Tecla > 255, Tecla-255, Tecla)
   ENDDO
   UltTecla = Tecla
   TclFin   = UPPER(CHR(Tecla))
ENDIF
*
* ------------------------------------------------------------------------
IF Restituir
   RESTORE SCREEN
ENDIF
RETURN TclFin

*********************
FUNC FIL_LOCK
*********************
PARAMETERS dWait
PRIVATE ForEver,Orig,Temp
Si      = .T.
No      = .F.
Orig    = dWait
ForEver = (Orig = 0)
Ok      = Si
SAVE SCREEN TO Temp                    && Guarda la Pantalla
IF ForEver
   @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
ENDIF
DO WHILE .T.
   IF .NOT. FLOCK()
      Delay=100             &&
      DO WHILE Delay > 0    && Retardo de 1/2 Segundo
         Delay = Delay-1    &&
      ENDDO                 &&
      dWait = dWait - 1
      IF .NOT. (ForEver .or. dWait > 0)
         ?? CHR(7)
         @  7 ,26 say "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿"  COLOR SCHEME 7
         @  8 ,26 say "³    Archivo Protegido    ³"  COLOR SCHEME 7
         @  9 ,26 say "³    por  otro Usuario    ³"  COLOR SCHEME 7
         @ 10 ,26 say "³(A)bandonar  (R)eintentar³"  COLOR SCHEME 7
         @ 11 ,26 say "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ"  COLOR SCHEME 7
         Tecla = 0
         DO WHILE .NOT. CHR(Tecla)$"rRaA"
            Tecla    = INKEY(0)
            Tecla     = IIF(Tecla<0 .OR. Tecla>255,0,Tecla)
         ENDDO
         RESTORE SCREEN FROM Temp
         IF CHR(Tecla)$"Aa"
            Ok     = No
            EXIT
         ELSE
            @ 24,0 SAY PADC("  Un momento por favor   ",80) COLOR -
         ENDIF
         dWait    =  Orig
      ENDIF
   ELSE
      Ok     = Si
      exit
   ENDIF
ENDDO
* ------------------------------------------------------------------------
RESTORE SCREEN FROM Temp               && Reponemos la pantalla.
RETURN Ok
*******************
FUNCTION def_teclas
*******************
PUBLIC end,Home,pgup,pgdn,del,ins,f_izq,izquierda,f_der,Derecha,f_arr,Arriba,f_aba,Abajo,tab,backtab,backspace,enter
      
PUBLIC f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,sf1,sf2,sf3,sf4,sf5,sf6,sf7,sf8,sf9,ctrlw,lookup,borrar,esc,Escape_

home       = 1
end        = 6
pgup       = 18
pgdn       = 3
del        = 7
ins        = 22
f_izq      = 19
Izquierda	= 19
f_der      = 4
Derecha		= 4
f_arr      = 5
Arriba		= 5
f_aba      = 24
Abajo	   = 24
tab        = 9
backtab    = 15
backspace  = 127
enter      = 13
f1         = 28
f2         = -1
f3         = -2
f4         = -3
f5         = -4
f6         = -5
f7         = -6
f8         = -7
f9         = -8
f10        = -9
sf1        = 84
sf2        = 85
sf3        = 86
sf4        = 87
sf5        = 88
sf6        = 89
sf7        = 90
sf8        = 91
sf9        = 92
ctrlw      = 23
lookup     = -7
borrar     = -8
esc        = 27
Escape_		= 27

PUBLIC k_home,k_end,k_pgup,k_pgdn,k_del,k_ins,k_f_izq,k_f_arr,k_f_aba,k_f_der,;
   k_tab,k_backtab,k_backspace,k_enter,k_f1,k_f2,k_f3,k_f4,k_f5,k_f6,k_f7,;
   k_f8,k_f9,k_f10,k_sf1,k_sf2,k_sf3,k_sf4,k_sf5,k_sf6,k_sf7,k_sf8,k_sf9,;
   k_ctrlw,k_lookup,k_borrar,k_esc,m.bfiltro

k_home       = 1
k_end        = 6
k_pgup       = 18
k_pgdn       = 3
k_del        = 7
k_ins        = 22
k_f_izq      = 19
k_f_der      = 4
k_f_arr      = 5
k_f_aba      = 24
k_tab        = 9
k_backtab    = 15
k_backspace  = 127
k_enter      = 13
k_f1         = 28
k_f2         = -1
k_f3         = -2
k_f4         = -3
k_f5         = -4
k_f6         = -5
k_f7         = -6
k_f8         = -7
k_f9         = -8
k_f10        = -9
k_sf1        = 84
k_sf2        = 85
k_sf3        = 86
k_sf4        = 87
k_sf5        = 88
k_sf6        = 89
k_sf7        = 90
k_sf8        = 91
k_sf9        = 92
k_ctrlw      = 23
k_lookup     = -7
k_borrar     = -8
k_esc        = 27



CLEAR macros
RESTORE MACROS FROM ADMCONFG


**********************************************************************
*                        Procedure: CLAVE                            *
**********************************************************************
FUNCTION CLAVE
**********************************************************************
PARAMETER LsClave
PRIVATE XPassword,LiVeces,LsPassw,Ancho,Xo
XPassword = UPPER(DESCRIPT(LsClave,LEN(LsClave)))
IF EMPTY(XPassword)
   RETURN .T.
ENDIF
Ancho = 14+LEN(LsClave)
Xo = 40 - INT(Ancho/2)
DEFINE WINDOWS _CLAVE FROM 17,Xo TO 19,Xo+Ancho  COLOR SCHEME 13 SHADOWS
ACTIVATE WINDOWS _CLAVE
LiVeces  = 1
LsPassW  = SPACE(LEN(LsClave))
GLsPassW = SPACE(LEN(LsClave))
xFlg     = .F.
DO WHILE LiVeces <= 3
   IF xFlg
      EXIT
   ENDIF
   @ 0,11 SAY REPLI(' ',LEN(LsPassw)+1)
   LsPassW  = SPACE(LEN(LsPassw))
   GLsPassW = SPACE(LEN(LsPassw))
   LinIm    = 1
   DO WHILE LASTKEY()<>27 .AND. LinIm <= LEN(LsPassW)
      @ 0,1  SAY "Clave    :"
      C=INKEY(0)
      IF C=5 &&Flecha Arriba
         @00,10+LinIm SAY REPLI(' ',LEN(Password))
         EXIT
      ENDIF
      IF LASTKEY()#13 .AND. C <> 13
         IF LASTKEY()=127 .AND. LinIm>0 &&BACK
            @00,10+LinIm SAY ' '
            LinIm = LinIm - 1
            GLsPassw = LEFT(ALLT(GLsPassW),LinIm)
         ELSE
            IF LASTKEY() <> 127 &&BACK
               @00,10+LinIm SAY ""
               GLsPassw = GLsPassw + UPPER(CHR(C))
               LinIm = LinIm + 1
            ENDIF
         ENDIF
      ELSE
         EXIT
      ENDIF
      IF LASTKEY()=27
         xFlg = .T.
         EXIT
      ENDIF
      @00,10+LinIm SAY CHR(15)
      IF ALLT(XPassword) == ALLT(GLsPassw)
         xFlg = .T.
         EXIT
      ENDIF
   ENDDO
   IF ! xFlg
      ?? CHR(7)
      WAIT "Invalida Clave" WINDOWS NOWAIT
   ENDIF
   LiVeces = LiVeces + 1
ENDDO
RELEASE  WINDOWS _CLAVE
IF ALLT(XPassword) == ALLT(GLsPassw) .AND. LASTKEY() <> 27
   RETURN .T.
ENDIF
RETURN .F.
